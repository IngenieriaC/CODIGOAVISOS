# -*- coding: utf-8 -*-
"""avisos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0ucN4kG4Y3v2ym3Sdye9h_33n32RKUH
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re
import io # Importamos io para manejar archivos en memoria
import numpy as np # Importamos numpy para c√°lculos num√©ricos

# --- Configuraci√≥n de la p√°gina (tem√°tica Sura) ---
st.set_page_config(
    page_title="Gerencia de Gesti√≥n Administrativa - Sura",
    layout="wide",
    initial_sidebar_state="expanded",
    # Icono de la p√°gina (opcional, puedes cambiar 'üìà' por el tuyo)
    # Abre este enlace para ver m√°s emojis: https://www.webfx.com/tools/emoji-cheat-sheet/
)

# Estilos CSS para ambientar en amarillo, blanco y azul rey
st.markdown(
    """
    <style>
    /* Estilos generales del fondo con degradado */
    .stApp {
        background: linear-gradient(to right, #FFFFFF, #FFFACD, #4169E1); /* Blanco, Amarillo claro (Cream), Azul Rey */
        color: #333333; /* Color de texto general */
    }
    /* Sidebar */
    .st-emotion-cache-1oe6z58 { /* Esta clase puede cambiar en futuras versiones de Streamlit */
        background-color: #F0F8FF; /* Azul claro para la sidebar */
    }
    /* T√≠tulos */
    h1, h2, h3, h4, h5, h6 {
        color: #4169E1; /* Azul Rey para los t√≠tulos */
    }
    /* Botones */
    .stButton>button {
        background-color: #4169E1; /* Azul Rey para los botones */
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.3s ease;
    }
    .stButton>button:hover {
        background-color: #F8D568; /* Amarillo para hover */
        color: #4169E1;
        border: 1px solid #4169E1;
    }
    /* Contenedores de contenido principal */
    .st-emotion-cache-z5fcl4, .st-emotion-cache-1c7y2kl, .st-emotion-cache-nahz7x { /* Clases gen√©ricas para contenedores */
        background-color: rgba(255, 255, 255, 0.9); /* Blanco semitransparente */
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
    }
    /* Mejoras para la tabla (dataframe) */
    .streamlit-dataframe {
        border-radius: 0.5rem;
        overflow: hidden; /* Asegura que las esquinas redondeadas se apliquen bien */
    }
    </style>
    """,
    unsafe_allow_html=True
)

# --- Bienvenida y encabezado ---
st.title("¬°Hola, usuario Sura! üëã")
st.markdown("---")
st.header("Proyecto de **Gerencia de Gesti√≥n Administrativa** en Ingenier√≠a Cl√≠nica")
st.markdown("""
    Aqu√≠ podr√°s **analizar y gestionar los datos de avisos** para optimizar los procesos.
    Por favor, **sube el archivo `DATA2.XLSX`** para comenzar.
""")

# --- Funci√≥n de carga & uni√≥n (optimizada para Streamlit) ---
@st.cache_data
def load_and_merge_data(uploaded_file_buffer: io.BytesIO) -> pd.DataFrame:
    """
    Carga y fusiona los datos de las diferentes hojas de un archivo Excel.

    Args:
        uploaded_file_buffer (io.BytesIO): Buffer del archivo Excel subido por el usuario.

    Returns:
        pd.DataFrame: El DataFrame combinado y limpio.
    """
    # Cargar hojas directamente desde el buffer
    iw29 = pd.read_excel(uploaded_file_buffer, sheet_name=0)
    uploaded_file_buffer.seek(0) # Rebobinar el buffer para leer la siguiente hoja
    iw39 = pd.read_excel(uploaded_file_buffer, sheet_name=1)
    uploaded_file_buffer.seek(0)
    ih08 = pd.read_excel(uploaded_file_buffer, sheet_name=2)
    uploaded_file_buffer.seek(0)
    iw65 = pd.read_excel(uploaded_file_buffer, sheet_name=3)
    uploaded_file_buffer.seek(0)
    zpm015 = pd.read_excel(uploaded_file_buffer, sheet_name=4)

    # Limpiar encabezados
    for df_temp in (iw29, iw39, ih08, iw65, zpm015):
        df_temp.columns = df_temp.columns.str.strip()

    # Guardar "Equipo" original desde IW29 para evitar p√©rdida
    # Aseg√∫rate de que 'Descripci√≥n' tambi√©n est√© en el equipo_original si se usa m√°s adelante
    equipo_original = iw29[["Aviso", "Equipo", "Duraci√≥n de parada", "Descripci√≥n"]].copy()

    # Extraer solo columnas necesarias de iw39 para el merge (incluyendo 'Total general (real)')
    iw39_subset = iw39[["Aviso", "Total general (real)"]]

    # Unir por 'Aviso'
    tmp1 = pd.merge(iw29, iw39_subset, on="Aviso", how="left")
    tmp2 = pd.merge(tmp1, iw65, on="Aviso", how="left")
    
    # Restaurar el valor original de "Equipo" de IW29 despu√©s del merge
    # Asegurarse de que no haya duplicados antes de la uni√≥n si 'Equipo' ya existiera en tmp2
    if "Equipo" in tmp2.columns:
        tmp2.drop(columns=["Equipo"], errors='ignore', inplace=True)
    tmp2 = pd.merge(tmp2, equipo_original, on="Aviso", how="left")

   # Unir por 'Equipo' con IH08
    tmp3 = pd.merge(tmp2, ih08[[
        "Equipo", "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto", "Indicador ABC",
        "Denominaci√≥n de objeto t√©cnico", "Cl.objeto t√©cnico" # <--- ¬°Cambiado aqu√≠!
    ]], on="Equipo", how="left")

    # Unir por 'Equipo' con ZPM015
    tmp4 = pd.merge(tmp3, zpm015[["Equipo", "TIPO DE SERVICIO"]], on="Equipo", how="left")
    # Renombrar columnas
    tmp4.rename(columns={
        "Texto": "Texto_equipo",
        "Total general (real)": "Costes tot.reales"
    }, inplace=True)

    columnas_finales = [
        "Aviso", "Orden", "Fecha de aviso", "C√≥digo postal", "Status del sistema",
        "Descripci√≥n", "Ubicaci√≥n t√©cnica", "Indicador", "Equipo",
        "Denominaci√≥n de objeto t√©cnico", "Denominaci√≥n ejecutante",
        "Duraci√≥n de parada", "Centro de coste", "Costes tot.reales",
        "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto_equipo",
        "Indicador ABC", "Texto c√≥digo acci√≥n", "Texto de acci√≥n",
        "Texto grupo acci√≥n", "TIPO DE SERVICIO", # Aseg√∫rate de que TIPO DE SERVICIO est√© aqu√≠
        "Clase de actividad", "Puesto de trabajo" # Incluir las nuevas columnas
    ]

    # Filtrar solo las columnas que realmente existen en tmp4
    columnas_finales = [col for col in columnas_finales if col in tmp4.columns]

    return tmp4[columnas_finales]

# --- HORARIO Mapping ---
horarios_dict = {
    "HORARIO_99": (17, 364.91), "HORARIO_98": (14.5, 312.78), "HORARIO_97": (9.818181818, 286.715),
    "HORARIO_96": (14.5, 312.78), "HORARIO_95": (4, 208.52), "HORARIO_93": (13.45454545, 286.715),
    "HORARIO_92": (6, 338.845), "HORARIO_91": (9.25, 312.78), "HORARIO_90": (11, 260.65),
    "HORARIO_9": (16, 312.78), "HORARIO_89": (9.5, 260.65), "HORARIO_88": (14, 260.65),
    "HORARIO_87": (9.333333333, 312.78), "HORARIO_86": (9.666666667, 312.78), "HORARIO_85": (12, 312.78),
    "HORARIO_84": (9.5, 312.78), "HORARIO_83": (8.416666667, 312.78), "HORARIO_82": (6, 312.78),
    "HORARIO_81": (10, 312.78), "HORARIO_80": (8.5, 312.78), "HORARIO_8": (11.6, 260.65),
    "HORARIO_79": (14, 312.78), "HORARIO_78": (12, 312.78), "HORARIO_77": (3, 312.78),
    "HORARIO_76": (16, 312.78), "HORARIO_75": (12.16666667, 312.78), "HORARIO_74": (11.33333333, 312.78),
    "HORARIO_73": (12.66666667, 312.78), "HORARIO_72": (11.83333333, 312.78), "HORARIO_71": (11, 312.78),
    "HORARIO_70": (15.16666667, 312.78), "HORARIO_7": (15.33333333, 312.78), "HORARIO_69": (9.166666667, 312.78),
    "HORARIO_68": (4, 312.78), "HORARIO_67": (10, 260.65), "HORARIO_66": (4, 260.65),
    "HORARIO_65": (16.76923077, 338.845), "HORARIO_64": (17.15384615, 338.845), "HORARIO_63": (22.5, 312.78),
    "HORARIO_62": (12.25, 312.78), "HORARIO_61": (4, 312.78), "HORARIO_60": (13, 312.78),
    "HORARIO_6": (18.46153846, 338.845), "HORARIO_59": (12.66666667, 312.78), "HORARIO_58": (12.33333333, 312.78),
    "HORARIO_57": (13.53846154, 338.845), "HORARIO_56": (12.16666667, 312.78), "HORARIO_55": (6.333333333, 312.78),
    "HORARIO_54": (7.230769231, 338.845), "HORARIO_53": (5.5, 312.78), "HORARIO_52": (4, 312.78),
    "HORARIO_51": (14, 338.845), "HORARIO_50": (15, 312.78), "HORARIO_5": (17, 312.78),
    "HORARIO_49": (15.27272727, 286.715), "HORARIO_48": (14.76923077, 338.845), "HORARIO_47": (14.5, 312.78),
    "HORARIO_46": (14.33333333, 312.78), "HORARIO_45": (14.16666667, 312.78), "HORARIO_44": (13.83333333, 312.78),
    "HORARIO_43": (13.5, 312.78), "HORARIO_42": (13.91666667, 312.78), "HORARIO_41": (15, 364.91),
    "HORARIO_40": (15.81818182, 286.715), "HORARIO_4": (16.16666667, 312.78), "HORARIO_39": (15.27272727, 286.715),
    "HORARIO_38": (13.84615385, 338.845), "HORARIO_37": (15.09090909, 286.715), "HORARIO_36": (14, 364.91),
    "HORARIO_35": (14.30769231, 338.845), "HORARIO_34": (14.90909091, 286.715), "HORARIO_33": (13.55, 312.78),
    "HORARIO_32": (14, 338.845), "HORARIO_31": (14.72727273, 286.715), "HORARIO_30": (13.08333333, 312.78),
    "HORARIO_3": (16, 312.78), "HORARIO_29": (14, 286.715), "HORARIO_28": (13, 364.91),
    "HORARIO_27": (14, 286.715), "HORARIO_26": (12.58333333, 312.78), "HORARIO_25": (12, 312.78),
    "HORARIO_24": (13.27272727, 286.715), "HORARIO_23": (11.83333333, 312.78), "HORARIO_22": (11.91666667, 312.78),
    "HORARIO_21": (13.09090909, 286.715), "HORARIO_20": (5, 312.78), "HORARIO_2": (23.5, 364.91),
    "HORARIO_19": (12.18181818, 286.715), "HORARIO_18": (5, 312.78), "HORARIO_17": (9.75, 312.78),
    "HORARIO_16": (10.36363636, 286.715), "HORARIO_15": (10.18181818, 286.715), "HORARIO_14": (8.5, 312.78),
    "HORARIO_134": (12, 364.91), "HORARIO_133": (12, 260.65), "HORARIO_132": (13, 312.78),
    "HORARIO_131": (10, 312.78), "HORARIO_130": (11, 260.65), "HORARIO_13": (9.454545455, 286.715),
    "HORARIO_129": (9.384615385, 338.845), "HORARIO_128": (12.33333333, 312.78), "HORARIO_127": (9.666666667, 312.78),
    "HORARIO_126": (10.83333333, 312.78), "HORARIO_125": (4, 312.78), "HORARIO_124": (13.66666667, 312.78),
    "HORARIO_123": (16.61538462, 338.845), "HORARIO_122": (11, 260.65), "HORARIO_121": (11.66666667, 312.78),
    "HORARIO_120": (8.25, 312.78), "HORARIO_12": (9.272727273, 286.715), "HORARIO_119": (11.23076923, 338.845),
    "HORARIO_118": (11.27272727, 286.715), "HORARIO_117": (11.41666667, 312.78), "HORARIO_116": (11, 312.78),
    "HORARIO_115": (9.25, 312.78), "HORARIO_114": (23.07692308, 338.845), "HORARIO_113": (20, 338.845),
    "HORARIO_112": (10.61538462, 338.845), "HORARIO_111": (9.454545455, 286.715), "HORARIO_110": (6.833333333, 312.78),
    "HORARIO_11": (8, 312.78), "HORARIO_109": (12.90909091, 286.715), "HORARIO_108": (10.54545455, 286.715),
    "HORARIO_107": (12.61538462, 338.845), "HORARIO_106": (14.76923077, 338.845), "HORARIO_105": (12, 156.39),
    "HORARIO_104": (7.666666667, 312.78), "HORARIO_103": (3, 260.65), "HORARIO_102": (10.16666667, 312.78),
    "HORARIO_101": (12, 260.65), "HORARIO_100": (11.16666667, 312.78), "HORARIO_10": (6, 312.78),
    "HORARIO_1": (24, 364.91),
}

# --- Funciones para calcular indicadores de desempe√±o t√©cnico ---
def calcular_disponibilidad(df_subset: pd.DataFrame, horarios: dict) -> pd.Series:
    """Calcula la disponibilidad promedio por Equipo."""
    if df_subset.empty:
        return pd.Series(dtype=float)

    # Convertir 'Duraci√≥n de parada' a num√©rica, reemplazando no num√©ricos con 0
    df_subset['Duraci√≥n de parada'] = pd.to_numeric(df_subset['Duraci√≥n de parada'], errors='coerce').fillna(0)

    # Identificar horarios de los equipos. Asumo que el horario se puede inferir del 'Equipo' o 'Denominaci√≥n de objeto t√©cnico'
    # Esta parte puede necesitar ajuste si la columna 'HORARIO' no existe o si la l√≥gica es m√°s compleja
    # Para el ejemplo, usaremos 'Denominaci√≥n de objeto t√©cnico' para buscar el horario
    
    # Crea una columna 'Horario_Asignado' basada en la 'Denominaci√≥n de objeto t√©cnico' o 'Equipo'
    # Asume que el horario est√° en 'Texto_equipo' o alguna columna similar que no est√° en el dataset de avisos directamente
    # Para este ejemplo, lo dejaremos como un valor fijo si no hay una columna que mapee a los horarios_dict keys.
    # Si 'ih08' tiene una columna 'Horario' o similar, se deber√≠a usar. Por ahora, asumimos un horario por defecto si no se encuentra.

    # Paso 1: Intentar obtener el 'HORARIO_XX' desde 'Denominaci√≥n de objeto t√©cnico' o 'Texto_equipo' si es posible
    # Esto es una suposici√≥n. Si el 'HORARIO_XX' est√° en otra columna, se debe ajustar.
    
    # Creamos una columna temporal para mapear horarios
    df_subset['Horario_Key'] = df_subset['Denominaci√≥n de objeto t√©cnico'].apply(
        lambda x: next((key for key in horarios.keys() if key.lower() in str(x).lower()), None)
    )

    # Si no se encuentra un horario espec√≠fico para el equipo, se puede asignar uno por defecto o un promedio
    # Para este ejemplo, usaremos un promedio de horas/d√≠a y d√≠as/a√±o si no se encuentra un horario espec√≠fico
    default_horas_dia = np.mean([h[0] for h in horarios.values()])
    default_dias_anio = np.mean([h[1] for h in horarios.values()])

    df_subset['Horas_Dia_Equipo'] = df_subset.apply(
        lambda row: horarios[row['Horario_Key']][0] if row['Horario_Key'] in horarios else default_horas_dia,
        axis=1
    )
    df_subset['Dias_Anio_Equipo'] = df_subset.apply(
        lambda row: horarios[row['Horario_Key']][1] if row['Horario_Key'] in horarios else default_dias_anio,
        axis=1
    )

    df_subset['Horas_Operativas_Totales'] = df_subset['Horas_Dia_Equipo'] * df_subset['Dias_Anio_Equipo']

    # Agrupar por tipo de servicio (o equipo, si la evaluaci√≥n es por equipo) y calcular la disponibilidad
    # La disponibilidad se calcula por equipo, y luego se podr√≠a promediar por tipo de servicio si es necesario.
    
    # Calculamos la suma de duraci√≥n de parada por equipo
    sum_parada_equipo = df_subset.groupby('Equipo')['Duraci√≥n de parada'].sum()
    
    # Obtenemos las horas operativas totales √∫nicas por equipo
    horas_op_equipo = df_subset.drop_duplicates(subset='Equipo').set_index('Equipo')['Horas_Operativas_Totales']

    # Asegurarse de que ambos Series tienen el mismo √≠ndice para la operaci√≥n
    horas_op_equipo = horas_op_equipo.reindex(sum_parada_equipo.index).fillna(0)

    # Calcular disponibilidad por equipo
    disponibilidad_equipo = (horas_op_equipo - sum_parada_equipo) / horas_op_equipo * 100
    disponibilidad_equipo = disponibilidad_equipo.replace([-np.inf, np.inf], np.nan).fillna(0) # Manejar divisiones por cero

    # Si la evaluaci√≥n es por TIPO DE SERVICIO, promediamos la disponibilidad de los equipos por servicio
    disponibilidad_por_servicio = df_subset.groupby('TIPO DE SERVICIO')['Equipo'].apply(
        lambda equipos: disponibilidad_equipo[equipos.unique()].mean()
    )
    return disponibilidad_por_servicio

def calcular_mttr(df_subset: pd.DataFrame) -> pd.Series:
    """Calcula el MTTR promedio por Tipo de Servicio."""
    if df_subset.empty:
        return pd.Series(dtype=float)
    df_subset['Duraci√≥n de parada'] = pd.to_numeric(df_subset['Duraci√≥n de parada'], errors='coerce').fillna(0)
    # MTTR = Suma de Duraci√≥n de Parada / Cantidad de Avisos
    mttr = df_subset.groupby('TIPO DE SERVICIO').apply(
        lambda x: x['Duraci√≥n de parada'].sum() / x['Aviso'].nunique() if x['Aviso'].nunique() > 0 else 0
    )
    return mttr.replace([np.inf, -np.inf], np.nan).fillna(0)

def calcular_mtbf(df_subset: pd.DataFrame, horarios: dict) -> pd.Series:
    """Calcula el MTBF promedio por Tipo de Servicio."""
    if df_subset.empty:
        return pd.Series(dtype=float)

    df_subset['Duraci√≥n de parada'] = pd.to_numeric(df_subset['Duraci√≥n de parada'], errors='coerce').fillna(0)

    # Calcular horas operativas totales por equipo (reusando la l√≥gica de disponibilidad)
    df_subset['Horario_Key'] = df_subset['Denominaci√≥n de objeto t√©cnico'].apply(
        lambda x: next((key for key in horarios.keys() if key.lower() in str(x).lower()), None)
    )
    default_horas_dia = np.mean([h[0] for h in horarios.values()])
    default_dias_anio = np.mean([h[1] for h in horarios.values()])

    df_subset['Horas_Dia_Equipo'] = df_subset.apply(
        lambda row: horarios[row['Horario_Key']][0] if row['Horario_Key'] in horarios else default_horas_dia,
        axis=1
    )
    df_subset['Dias_Anio_Equipo'] = df_subset.apply(
        lambda row: horarios[row['Horario_Key']][1] if row['Horario_Key'] in horarios else default_dias_anio,
        axis=1
    )
    df_subset['Horas_Operativas_Totales_Equipo'] = df_subset['Horas_Dia_Equipo'] * df_subset['Dias_Anio_Equipo']

    # Suma de la duraci√≥n de parada por equipo
    total_parada_por_equipo = df_subset.groupby('Equipo')['Duraci√≥n de parada'].sum()
    
    # N√∫mero de avisos por equipo (considerando cada aviso como una "falla" para MTBF simplificado)
    num_avisos_por_equipo = df_subset.groupby('Equipo')['Aviso'].nunique()

    # Horas operativas totales √∫nicas por equipo
    horas_op_unicas_equipo = df_subset.drop_duplicates(subset='Equipo').set_index('Equipo')['Horas_Operativas_Totales_Equipo']

    # Asegurarse de que todos los Series tienen el mismo √≠ndice
    total_parada_por_equipo = total_parada_por_equipo.reindex(horas_op_unicas_equipo.index).fillna(0)
    num_avisos_por_equipo = num_avisos_por_equipo.reindex(horas_op_unicas_equipo.index).fillna(0)

    # Calcular MTBF por equipo
    # Si num_avisos_por_equipo es 0, MTBF es infinito (o NaN, o 0 para evitar errores)
    mtbf_equipo = (horas_op_unicas_equipo - total_parada_por_equipo) / num_avisos_por_equipo
    mtbf_equipo = mtbf_equipo.replace([np.inf, -np.inf], np.nan).fillna(0) # Manejar divisiones por cero

    # Si la evaluaci√≥n es por TIPO DE SERVICIO, promediamos el MTBF de los equipos por servicio
    mtbf_por_servicio = df_subset.groupby('TIPO DE SERVICIO')['Equipo'].apply(
        lambda equipos: mtbf_equipo[equipos.unique()].mean()
    )
    return mtbf_por_servicio

def clasificar_rendimiento(disponibilidad: pd.Series) -> pd.Series:
    """Clasifica el rendimiento en 'Alto', 'Medio' o 'Bajo' basado en la disponibilidad."""
    if disponibilidad.empty:
        return pd.Series(dtype=str)
    
    return disponibilidad.apply(
        lambda disp: 'Alto' if disp >= 90 else ('Medio' if disp >= 75 else 'Bajo')
    )

# --- Definici√≥n de las preguntas y rangos ---
rangos_detallados = {
    "Calidad": {
        "¬øLas soluciones propuestas son coherentes con el diagn√≥stico y causa ra√≠z del problema?": {
            2: "Total coherencia con el diagn√≥stico y causas identificadas",
            1: "Coherencia razonable, con peque√±os ajustes necesarios",
            0: "Cumple con lo b√°sico, pero con limitaciones relevantes",
            -1: "No guarda coherencia o es deficiente respecto al diagn√≥stico"
        },
        "¬øEl trabajo entregado tiene materiales nuevos, originales y de marcas reconocidas?": {
            2: "Todos los materiales son nuevos, originales y de marcas reconocidas",
            1: "La mayor√≠a de los materiales cumplen esas condiciones",
            0: "Algunos materiales no son nuevos o no est√°n certificados",
            -1: "Materiales gen√©ricos, usados o sin respaldo de marca"
        },
        "¬øCuenta con acabados homog√©neos, limpios y pulidos?": {
            2: "Acabados uniformes, bien presentados y profesionales",
            1: "En general, los acabados son aceptables y limpios",
            0: "Presenta inconsistencias notorias en algunos acabados",
            -1: "Acabados descuidados, sucios o sin terminaci√≥n adecuada"
        },
        "¬øEl trabajo entregado corresponde completamente con lo contratado?": {
            2: "Cumple en su totalidad con lo contratado y acordado",
            1: "Cumple en gran parte con lo contratado, con m√≠nimos desv√≠os",
            0: "Cumple con los requisitos m√≠nimos establecidos",
            -1: "No corresponde con lo contratado o presenta deficiencias importantes"
        },
        "¬øLa facturaci√≥n refleja correctamente lo ejecutado y acordado?": {
            2: "Facturaci√≥n precisa, sin errores y con toda la informaci√≥n requerida",
            1: "Facturaci√≥n con peque√±os errores que no afectan el control",
            0: "Facturaci√≥n con errores importantes (por ejemplo, precios)",
            -1: "Facturaci√≥n incorrecta, incompleta o que requiere ser repetida"
        }
    },
    "Oportunidad": {
        "¬øLa entrega de cotizaciones fue oportuna, seg√∫n el contrato?": {
            2: "Siempre entrega cotizaciones en los tiempos establecidos",
            1: "Generalmente cumple con los plazos establecidos",
            0: "A veces entrega fuera del tiempo estipulado",
            -1: "Frecuentemente incumple los tiempos o no entrega"
        },
        "¬øEl reporte del servicio fue entregado oportunamente, seg√∫n el contrato?": {
            2: "Siempre entrega los reportes a tiempo, seg√∫n lo acordado",
            1: "Entrega los reportes con m√≠nimos retrasos",
            0: "Entrega con demoras ocasionales",
            -1: "Entrega tard√≠a constante o no entrega"
        },
        "¬øCumple las fechas y horas programadas para los trabajos, seg√∫n el contrato?": {
            2: "Puntualidad absoluta en fechas y horarios de ejecuci√≥n",
            1: "Puntualidad general con excepciones menores",
            0: "Cumplimiento parcial o con retrasos frecuentes",
            -1: "Incumplimiento reiterado de horarios o fechas"
        },
        "¬øResponde de forma efectiva ante eventualidades emergentes, seg√∫n el contrato?": {
            2: "Respuesta inmediata y eficaz ante cualquier eventualidad",
            1: "Respuesta adecuada en la mayor√≠a de los casos",
            0: "Respuesta tard√≠a o poco efectiva en varias situaciones",
            -1: "No responde adecuadamente o ignora emergencias"
        },
        "¬øSoluciona r√°pidamente reclamos o inquietudes por garant√≠a, seg√∫n el contrato?": {
            2: "Soluciona siempre con rapidez y eficacia",
            1: "Responde satisfactoriamente en la mayor√≠a de los casos",
            0: "Respuesta variable, con demoras ocasionales",
            -1: "Soluciones lentas o sin resolver adecuadamente"
        },
        "¬øDispone de los repuestos requeridos en los tiempos necesarios, seg√∫n el contrato?": {
            2: "Siempre cuenta con repuestos disponibles en el tiempo requerido",
            1: "Generalmente cumple con la disponibilidad de repuestos",
            0: "Disponibilidad intermitente o con retrasos",
            -1: "No garantiza disponibilidad o presenta retrasos constantes"
        },
        "¬øEntrega las facturas en los tiempos convenidos, seg√∫n el contrato?": {
            2: "Entrega siempre puntual de facturas",
            1: "Entrega generalmente puntual con pocas excepciones",
            0: "Entrega ocasionalmente fuera del tiempo acordado",
            -1: "Entrega tarde con frecuencia o no entrega"
        }
    },
    "Precio": {
        "¬øLos precios ofrecidos para equipos son competitivos respecto al mercado?": {
            2: "Muy por debajo del precio promedio de mercado",
            1: "Por debajo del promedio de mercado",
            0: "Igual al promedio de mercado",
            -1: "Por encima del promedio de mercado"
        },
        "¬øLos precios ofrecidos para repuestos son competitivos respecto al mercado?": {
            2: "Muy por debajo del precio promedio de mercado",
            1: "Por debajo del promedio de mercado",
            0: "Igual al promedio de mercado",
            -1: "Por encima del promedio de mercado"
        },
        "Facilita llegar a una negociaci√≥n (precios)": {
            2: "Siempre est√° dispuesto a negociar de manera flexible",
            1: "En general muestra disposici√≥n al di√°logo",
            0: "Ocasionalmente permite negociar",
            -1: "Poco o nada dispuesto a negociar"
        },
        "Pone en consideraci√≥n contratos y trabajos adjudicados en el √∫ltimo periodo de tiempo": {
            2: "Siempre toma en cuenta la relaci√≥n comercial previa",
            1: "Generalmente considera trabajos anteriores",
            0: "Solo ocasionalmente lo toma en cuenta",
            -1: "No muestra continuidad ni reconocimiento de antecedentes"
        },
        "¬øLos precios ofrecidos para mantenimientos son competitivos respecto al mercado?": {
            2: "Muy por debajo del precio promedio de mercado",
            1: "Por debajo del promedio de mercado",
            0: "Igual al promedio de mercado",
            -1: "Por encima del promedio de mercado"
        },
        "¬øLos precios ofrecidos para insumos son competitivos respecto al mercado?": {
            2: "Muy por debajo del precio promedio de mercado",
            1: "Por debajo del promedio de mercado",
            0: "Igual al promedio de mercado",
            -1: "Por encima del promedio de mercado"
        }
    },
    "Postventa": {
        "¬øTiene disposici√≥n y actitud de servicio frente a solicitudes?": {
            2: "Atenci√≥n proactiva y excelente actitud de servicio",
            1: "Buena actitud y disposici√≥n general",
            0: "Actitud pasiva o limitada ante las solicitudes",
            -1: "Falta de disposici√≥n o actitudes negativas"
        },
        "¬øConoce necesidades y ofrece alternativas adecuadas?": {
            2: "Conocimiento profundo del cliente y propuestas adecuadas",
            1: "Buen conocimiento y alternativas en general adecuadas",
            0: "Soluciones parcialmente adecuadas",
            -1: "No se adapta a las necesidades o propone soluciones inadecuadas"
        },
        "¬øRealiza seguimiento a los resultados de los trabajos?": {
            2: "Hace seguimiento sistem√°tico y detallado",
            1: "Realiza seguimiento general adecuado",
            0: "Seguimiento ocasional o no documentado",
            -1: "No realiza seguimiento posterior"
        },
        "¬øOfrece capacitaciones para el manejo de los equipos?": {
            2: "Capacitaciones constantes y bien estructuradas",
            1: "Capacitaciones ocasionales pero √∫tiles",
            0: "Capacitaciones m√≠nimas o informales",
            -1: "No ofrece capacitaciones"
        },
        "¬øLos m√©todos de capacitaci√≥n ofrecidos son efectivos y adecuados?": {
            2: "M√©todos claros, efectivos y adaptados al usuario",
            1: "M√©todos generalmente √∫tiles y comprensibles",
            0: "M√©todos poco claros o limitados",
            -1: "M√©todos ineficaces o mal estructurados"
        }
    },
    "Desempe√±o t√©cnico": {
        "Disponibilidad promedio (%)": {
            2: "Disponibilidad >= 98%",
            1: "75% <= Disponibilidad < 98%",
            0: "Disponibilidad < 75%"
        },
        "MTTR promedio (hrs)": {
            2: "MTTR <= 5 hrs",
            1: "5 hrs < MTTR <= 20 hrs",
            0: "MTTR > 20 hrs"
        },
        "MTBF promedio (hrs)": {
            2: "MTBF > 1000 hrs",
            1: "100 hrs <= MTBF <= 1000 hrs",
            0: "MTBF < 100 hrs"
        },
        "Rendimiento promedio equipos": {
            2: "Rendimiento 'Alto' (Disponibilidad >= 90%)",
            1: "Rendimiento 'Medio' (75% <= Disponibilidad < 90%)",
            0: "Rendimiento 'Bajo' (Disponibilidad < 75%)"
        }
    }
}

# --- Uploader y Ejecuci√≥n ---
uploaded_file = st.file_uploader("Sube tu archivo 'DATA2.XLSX' aqu√≠", type=["xlsx"])

if 'df' not in st.session_state:
    st.session_state.df = None
if 'current_page_eval' not in st.session_state:
    st.session_state.current_page_eval = 0
if 'eval_mode' not in st.session_state:
    st.session_state.eval_mode = "Por Tipo de Servicio" # Default evaluation mode
if 'selected_eval_target' not in st.session_state:
    st.session_state.selected_eval_target = None
if 'evaluations' not in st.session_state:
    st.session_state.evaluations = {} # Store user evaluations: {('Categor√≠a', 'Pregunta', 'Target'): valor}

if uploaded_file:
    file_buffer = io.BytesIO(uploaded_file.getvalue())

    with st.spinner('Cargando y procesando datos... Esto puede tomar un momento.'):
        try:
            df_processed = load_and_merge_data(file_buffer)

            # --- Procesamiento adicional ---
            # Eliminar registros cuyo 'Status del sistema' contenga "PTBO"
            initial_rows = len(df_processed)
            df_processed = df_processed[~df_processed["Status del sistema"].str.contains("PTBO", case=False, na=False)]
            st.info(f"Se eliminaron {initial_rows - len(df_processed)} registros con 'PTBO' en 'Status del sistema'.")

            # Dejar solo una fila con coste por cada aviso (esto parece para el original)
            # Para la evaluaci√≥n, el costo total real puede ser √∫til sumado por servicio o proveedor
            df_processed['Costes tot.reales'] = pd.to_numeric(df_processed['Costes tot.reales'], errors='coerce').fillna(0)
            
            # Ajustar la columna 'Duraci√≥n de parada' para que sea num√©rica
            df_processed['Duraci√≥n de parada'] = pd.to_numeric(df_processed['Duraci√≥n de parada'], errors='coerce').fillna(0)

            # Ensure 'Denominaci√≥n ejecutante' is the 'PROVEEDOR' column
            if 'Denominaci√≥n ejecutante' in df_processed.columns:
                df_processed.rename(columns={'Denominaci√≥n ejecutante': 'PROVEEDOR'}, inplace=True)
            else:
                st.warning("La columna 'Denominaci√≥n ejecutante' no se encontr√≥ para usar como 'PROVEEDOR'.")
                df_processed['PROVEEDOR'] = 'Desconocido' # Fallback

            st.session_state.df = df_processed

            st.success("‚úÖ Datos cargados y procesados exitosamente.")
            st.write(f"**Filas finales:** {len(st.session_state.df)} ‚Äì **Columnas:** {len(st.session_state.df.columns)}")

            # --- Visualizaci√≥n y Descarga ---
            st.markdown("---")
            st.subheader("Vista previa de los datos procesados:")
            st.dataframe(st.session_state.df.head(10)) # Mostrar m√°s filas para una mejor vista previa

            st.markdown("---")
            st.subheader("Descarga de Datos Procesados")

            # Preparar CSV para descarga
            csv_output = st.session_state.df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="Descargar como CSV",
                data=csv_output,
                file_name="avisos_filtrados.csv",
                mime="text/csv",
                help="Descarga el archivo en formato CSV."
            )

            # Preparar Excel para descarga
            excel_buffer = io.BytesIO()
            st.session_state.df.to_excel(excel_buffer, index=False, engine='openpyxl')
            excel_buffer.seek(0) # Rebobinar el buffer antes de enviarlo
            st.download_button(
                label="Descargar como Excel",
                data=excel_buffer,
                file_name="avisos_filtrados.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                help="Descarga el archivo en formato XLSX."
            )

            st.markdown("---")
            st.success("¬°El procesamiento ha finalizado! Ahora puedes descargar tus datos o seguir explorando.")

        except Exception as e:
            st.error(f"‚ùå ¬°Ups! Ocurri√≥ un error al procesar el archivo: {e}")
            st.warning("Por favor, verifica que el archivo subido sea `DATA2.XLSX` y tenga el formato de hojas esperado.")
            st.exception(e) # Muestra el traceback completo para depuraci√≥n
else:
    st.info("‚¨ÜÔ∏è Sube tu archivo `DATA2.XLSX` para empezar con el an√°lisis.")

# --- Secci√≥n de Evaluaci√≥n ---
if st.session_state.df is not None and not st.session_state.df.empty:
    st.markdown("---")
    st.title("üìä Evaluaci√≥n de Desempe√±o")
    st.markdown("""
        Utiliza esta secci√≥n para evaluar el desempe√±o de los **proveedores** o **tipos de servicio**
        basado en criterios de calidad, oportunidad, precio y desempe√±o t√©cnico.
    """)
    st.markdown("---")

    col1_eval, col2_eval = st.columns([1, 2])

    with col1_eval:
        st.session_state.eval_mode = st.radio(
            "Selecciona el modo de evaluaci√≥n:",
            ("Por Tipo de Servicio", "Por Proveedor"),
            key="eval_mode_selector"
        )
    
    # Obtener las opciones para el selector principal
    if st.session_state.eval_mode == "Por Tipo de Servicio":
        target_options = ['Todos los Servicios'] + sorted(st.session_state.df['TIPO DE SERVICIO'].dropna().unique().tolist())
    else: # Por Proveedor
        target_options = ['Todos los Proveedores'] + sorted(st.session_state.df['PROVEEDOR'].dropna().unique().tolist())

    with col2_eval:
        selected_target = st.selectbox(
            f"Selecciona {'un Tipo de Servicio' if st.session_state.eval_mode == 'Por Tipo de Servicio' else 'un Proveedor'}:",
            options=target_options,
            key="selected_eval_target_selector"
        )
        st.session_state.selected_eval_target = selected_target

    # Filtrar el DataFrame seg√∫n la selecci√≥n
    df_eval = st.session_state.df.copy()
    if st.session_state.eval_mode == "Por Tipo de Servicio":
        if selected_target != "Todos los Servicios":
            df_eval = df_eval[df_eval['TIPO DE SERVICIO'] == selected_target]
        else:
            # Si 'Todos los Servicios', no filtramos por TIPO DE SERVICIO, pero necesitamos los datos
            # agrupados por TIPO DE SERVICIO para los c√°lculos.
            pass
    else: # Por Proveedor
        if selected_target != "Todos los Proveedores":
            df_eval = df_eval[df_eval['PROVEEDOR'] == selected_target]
        else:
            # Si 'Todos los Proveedores', no filtramos por PROVEEDOR, pero necesitamos los datos
            # agrupados por PROVEEDOR para los c√°lculos.
            pass
    
    if df_eval.empty:
        st.warning(f"No hay datos disponibles para '{st.session_state.selected_eval_target}' en el modo '{st.session_state.eval_mode}'.")
    else:
        # Calcular indicadores de desempe√±o t√©cnico para el subconjunto de datos
        # Estos c√°lculos siempre se har√°n por TIPO DE SERVICIO o EQUIPO, dependiendo del modo
        if st.session_state.eval_mode == "Por Tipo de Servicio":
            # Si estamos evaluando por Tipo de Servicio, los KPIs deben ser para el tipo de servicio seleccionado
            # o promediados si es "Todos los Servicios"
            current_disponibilidad = calcular_disponibilidad(df_eval, horarios_dict)
            current_mttr = calcular_mttr(df_eval)
            current_mtbf = calcular_mtbf(df_eval, horarios_dict)
            current_rendimiento = clasificar_rendimiento(current_disponibilidad)
            
            # Si es "Todos los Servicios", necesitamos evaluar cada tipo de servicio individualmente
            if selected_target == "Todos los Servicios":
                targets_for_evaluation = sorted(df_eval['TIPO DE SERVICIO'].dropna().unique().tolist())
            else:
                targets_for_evaluation = [selected_target] # Solo el tipo de servicio seleccionado
            
        else: # Por Proveedor
            # Si estamos evaluando por Proveedor, los KPIs deben ser para los TIPOS DE SERVICIO de ese proveedor
            # Los c√°lculos siempre se har√°n por TIPO DE SERVICIO
            current_disponibilidad = calcular_disponibilidad(df_eval, horarios_dict)
            current_mttr = calcular_mttr(df_eval)
            current_mtbf = calcular_mtbf(df_eval, horarios_dict)
            current_rendimiento = clasificar_rendimiento(current_disponibilidad)

            # Necesitamos los tipos de servicio √∫nicos para el proveedor seleccionado
            if selected_target == "Todos los Proveedores":
                # Si es "Todos los Proveedores", evaluamos por cada tipo de servicio √∫nico en todo el DF
                targets_for_evaluation = sorted(st.session_state.df['TIPO DE SERVICIO'].dropna().unique().tolist())
            else:
                targets_for_evaluation = sorted(df_eval['TIPO DE SERVICIO'].dropna().unique().tolist())
        
        # Paginaci√≥n para "Por Proveedor" si hay muchos tipos de servicio
        items_per_page = 5
        total_pages = int(np.ceil(len(targets_for_evaluation) / items_per_page))

        col_prev, col_page_info, col_next = st.columns([1, 1, 1])
        with col_prev:
            if st.session_state.current_page_eval > 0:
                if st.button("P√°gina Anterior", key="prev_page_eval_button"):
                    st.session_state.current_page_eval -= 1
                    st.experimental_rerun()
        with col_page_info:
            if total_pages > 0:
                st.write(f"P√°gina {st.session_state.current_page_eval + 1} de {total_pages}")
            else:
                st.write("No hay elementos para mostrar.")
        with col_next:
            if st.session_state.current_page_eval < total_pages - 1:
                if st.button("P√°gina Siguiente", key="next_page_eval_button"):
                    st.session_state.current_page_eval += 1
                    st.experimental_rerun()

        start_idx = st.session_state.current_page_eval * items_per_page
        end_idx = start_idx + items_per_page
        targets_on_page = targets_for_evaluation[start_idx:end_idx]

        if not targets_on_page:
            st.info("No hay tipos de servicio/proveedores para mostrar en esta p√°gina.")
        else:
            st.markdown("---")
            st.subheader("Formulario de Evaluaci√≥n")

            # Preparar las cabeceras de los targets para la tabla
            cols = st.columns([0.3] + [0.7/len(targets_on_page)] * len(targets_on_page))
            cols[0].markdown("**Pregunta / Indicador**")
            for i, target_label in enumerate(targets_on_page):
                cols[i+1].markdown(f"**{target_label}**")
            
            evaluation_results = []

            for category, questions in rangos_detallados.items():
                st.markdown(f"#### {category}")
                for question, options in questions.items():
                    col_q, *cols_targets = st.columns([0.3] + [0.7/len(targets_on_page)] * len(targets_on_page))
                    col_q.markdown(f"**{question}**")

                    for i, target_eval in enumerate(targets_on_page):
                        key = (category, question, target_eval)
                        
                        if category == "Desempe√±o t√©cnico":
                            # Calculamos y mostramos el valor autom√°tico
                            val = 0
                            description = "N/A"
                            if "Disponibilidad" in question and target_eval in current_disponibilidad:
                                mean_disp = current_disponibilidad[target_eval]
                                if mean_disp >= 98: val = 2
                                elif mean_disp >= 75: val = 1
                                else: val = 0
                                description = f"{mean_disp:.2f}%"
                            elif "MTTR" in question and target_eval in current_mttr:
                                mean_mttr = current_mttr[target_eval]
                                if mean_mttr <= 5: val = 2
                                elif mean_mttr <= 20: val = 1
                                else: val = 0
                                description = f"{mean_mttr:.2f} hrs"
                            elif "MTBF" in question and target_eval in current_mtbf:
                                mean_mtbf = current_mtbf[target_eval]
                                if mean_mtbf > 1000: val = 2
                                elif mean_mtbf >= 100: val = 1
                                else: val = 0
                                description = f"{mean_mtbf:.2f} hrs"
                            elif "Rendimiento" in question and target_eval in current_rendimiento:
                                perf_class = current_rendimiento[target_eval]
                                if perf_class == 'Alto': val = 2
                                elif perf_class == 'Medio': val = 1
                                else: val = 0
                                description = perf_class
                            
                            cols_targets[i].metric(label="", value=f"{val} ({description})")
                            st.session_state.evaluations[key] = val # Guardar el valor calculado
                            
                        else:
                            # Preguntas con selecci√≥n manual
                            display_options = [(v, k) for k, v in options.items()]
                            current_value = st.session_state.evaluations.get(key, 0) # Default to 0
                            
                            selected_option = cols_targets[i].selectbox(
                                label=f"Califica para {target_eval}",
                                options=display_options,
                                index=next((j for j, (val_opt, desc_opt) in enumerate(display_options) if val_opt == current_value), 2), # Find index of current_value
                                key=f"eval_{category}_{question}_{target_eval}",
                                label_visibility="collapsed"
                            )
                            st.session_state.evaluations[key] = selected_option # Store the selected value
                        
                        # Add to results for export
                        evaluation_results.append({
                            'Categor√≠a': category,
                            'Pregunta': question,
                            st.session_state.eval_mode.replace("Por ", ""): target_eval, # Use "Tipo de Servicio" or "Proveedor"
                            'Puntuaci√≥n': st.session_state.evaluations[key],
                            'Descripci√≥n Puntuaci√≥n': options.get(st.session_state.evaluations[key], description if category == "Desempe√±o t√©cnico" else "N/A")
                        })
            
            st.markdown("---")
            if st.button("Guardar y Exportar Evaluaci√≥n", key="export_eval_button"):
                if evaluation_results:
                    df_eval_results = pd.DataFrame(evaluation_results)
                    
                    # Preparar CSV para descarga
                    csv_eval_output = df_eval_results.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Descargar Evaluaci√≥n como CSV",
                        data=csv_eval_output,
                        file_name="evaluacion_desempeno.csv",
                        mime="text/csv",
                        key="download_eval_csv"
                    )

                    # Preparar Excel para descarga
                    excel_eval_buffer = io.BytesIO()
                    df_eval_results.to_excel(excel_eval_buffer, index=False, engine='openpyxl')
                    excel_eval_buffer.seek(0)
                    st.download_button(
                        label="Descargar Evaluaci√≥n como Excel",
                        data=excel_eval_buffer,
                        file_name="evaluacion_desempeno.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        key="download_eval_excel"
                    )
                    st.success("Evaluaci√≥n guardada y lista para descargar.")
                else:
                    st.warning("No hay evaluaciones para guardar. Por favor, selecciona un objetivo y califica.")

else:
    st.info("Sube un archivo para habilitar la secci√≥n de evaluaci√≥n.")

# -*- coding: utf-8 -*-
"""code_avisos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Muqw1oykoxweSm1oapspkUwdGxE60Pw
"""

# -*- coding: utf-8 -*-
"""avisos_integrado

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0ucN4kG4Y3v2ym3Sdye9h_33n32RKUH
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re
import io
import numpy as np

# Set a nice style for plots
sns.set_style('whitegrid')

# --- Configuración de la página (temática Sura) ---
st.set_page_config(
    page_title="Gerencia de Gestión Administrativa - Sura",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Estilos CSS para ambientar en amarillo, blanco y azul rey
st.markdown(
    """
    <style>
    /* Estilos generales del fondo con degradado */
    .stApp {
        background: linear-gradient(to right, #FFFFFF, #FFFACD, #4169E1); /* Blanco, Amarillo claro (Cream), Azul Rey */
        color: #333333; /* Color de texto general */
    }
    /* Sidebar */
    .st-emotion-cache-1oe6z58 { /* Esta clase puede cambiar en futuras versiones de Streamlit */
        background-color: #F0F8FF; /* Azul claro para la sidebar */
    }
    /* Títulos */
    h1, h2, h3, h4, h5, h6 {
        color: #4169E1; /* Azul Rey para los títulos */
    }
    /* Botones */
    .stButton>button {
        background-color: #4169E1; /* Azul Rey para los botones */
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.3s ease;
    }
    .stButton>button:hover {
        background-color: #F8D568; /* Amarillo para hover */
        color: #4169E1;
        border: 1px solid #4169E1;
    }
    /* Contenedores de contenido principal */
    .st-emotion-cache-z5fcl4, .st-emotion-cache-1c7y2kl, .st-emotion-cache-nahz7x { /* Clases genéricas para contenedores */
        background-color: rgba(255, 255, 255, 0.9); /* Blanco semitransparente */
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
    }
    /* Mejoras para la tabla (dataframe) */
    .streamlit-dataframe {
        border-radius: 0.5rem;
        overflow: hidden; /* Asegura que las esquinas redondeadas se apliquen bien */
    }
    </style>
    """,
    unsafe_allow_html=True
)

# --- Función de carga & unión (optimizada para Streamlit) ---
@st.cache_data
def load_and_merge_data(uploaded_file_buffer: io.BytesIO) -> pd.DataFrame:
    """
    Carga y fusiona los datos de las diferentes hojas de un archivo Excel.

    Args:
        uploaded_file_buffer (io.BytesIO): Buffer del archivo Excel subido por el usuario.

    Returns:
        pd.DataFrame: El DataFrame combinado y limpio.
    """
    # Cargar hojas directamente desde el buffer
    iw29 = pd.read_excel(uploaded_file_buffer, sheet_name=0)
    uploaded_file_buffer.seek(0) # Rebobinar el buffer para leer la siguiente hoja
    iw39 = pd.read_excel(uploaded_file_buffer, sheet_name=1)
    uploaded_file_buffer.seek(0)
    ih08 = pd.read_excel(uploaded_file_buffer, sheet_name=2)
    uploaded_file_buffer.seek(0)
    iw65 = pd.read_excel(uploaded_file_buffer, sheet_name=3)
    uploaded_file_buffer.seek(0)
    zpm015 = pd.read_excel(uploaded_file_buffer, sheet_name=4)

    # Limpiar encabezados
    for df_temp in (iw29, iw39, ih08, iw65, zpm015):
        df_temp.columns = df_temp.columns.str.strip()

    # Guardar "Equipo" original desde IW29 para evitar pérdida
    equipo_original = iw29[["Aviso", "Equipo", "Duración de parada", "Descripción"]].copy()

    # Extraer solo columnas necesarias de iw39 para el merge (incluyendo 'Total general (real)')
    iw39_subset = iw39[["Aviso", "Total general (real)"]]

    # Unir por 'Aviso'
    tmp1 = pd.merge(iw29, iw39_subset, on="Aviso", how="left")
    tmp2 = pd.merge(tmp1, iw65, on="Aviso", how="left")

    # Restaurar el valor original de "Equipo" de IW29 después del merge
    tmp2.drop(columns=["Equipo"], errors='ignore', inplace=True)
    tmp2 = pd.merge(tmp2, equipo_original, on="Aviso", how="left")

    # Unir por 'Equipo' con IH08
    tmp3 = pd.merge(tmp2, ih08[[
        "Equipo", "Inic.garantía prov.", "Fin garantía prov.", "Texto", "Indicador ABC", "Denominación de objeto técnico"
    ]], on="Equipo", how="left")

    # Unir por 'Equipo' con ZPM015
    tmp4 = pd.merge(tmp3, zpm015[["Equipo", "TIPO DE SERVICIO"]], on="Equipo", how="left")

    # Renombrar columnas
    tmp4.rename(columns={
        "Texto": "Texto_equipo",
        "Total general (real)": "Costes tot.reales"
    }, inplace=True)

    columnas_finales = [
        "Aviso", "Orden", "Fecha de aviso", "Código postal", "Status del sistema",
        "Descripción", "Ubicación técnica", "Indicador", "Equipo",
        "Denominación de objeto técnico", "Denominación ejecutante",
        "Duración de parada", "Centro de coste", "Costes tot.reales",
        "Inic.garantía prov.", "Fin garantía prov.", "Texto_equipo",
        "Indicador ABC", "Texto código acción", "Texto de acción",
        "Texto grupo acción", "TIPO DE SERVICIO"
    ]

    # Filtrar solo las columnas que realmente existen en tmp4
    columnas_finales = [col for col in columnas_finales if col in tmp4.columns]

    df = tmp4[columnas_finales]

    # Normalize column names more robustly from code_avisos (1).py
    ORIGINAL_EJECUTANTE_COL_NAME = "Denominación ejecutante"
    ORIGINAL_CP_COL_NAME = "Código postal"
    ORIGINAL_OBJETO_TECNICO_COL_NAME = "Denominación de objeto técnico"
    ORIGINAL_TEXTO_CODIGO_ACCION_COL_NAME = "Texto código acción"
    ORIGINAL_TEXTO_ACCION_COL_NAME = "Texto de acción"
    ORIGINAL_TIPO_SERVICIO_COL_NAME = "Tipo de servicio"
    ORIGINAL_COSTOS_COL_NAME = "Costes tot.reales"
    ORIGINAL_DESCRIPTION_COL_NAME = "Descripción"
    ORIGINAL_FECHA_AVISO_COL_NAME = "Fecha de aviso"
    ORIGINAL_TEXTO_POSICION_COL_NAME = "Texto de Posición" # This is the missing column
    ORIGINAL_TEXTO_EQUIPO_COL_NAME = "Texto_equipo"
    ORIGINAL_DURACION_PARADA_COL_NAME = "Duración de parada"
    ORIGINAL_EQUIPO_COL_NAME = "Equipo"
    ORIGINAL_AVISO_COL_NAME = "Aviso"

    column_mapping = {
        ORIGINAL_EJECUTANTE_COL_NAME: "denominacion_ejecutante",
        ORIGINAL_CP_COL_NAME: "codigo_postal",
        ORIGINAL_OBJETO_TECNICO_COL_NAME: "denominacion_de_objeto_tecnico",
        ORIGINAL_TEXTO_CODIGO_ACCION_COL_NAME: "texto_codigo_accion",
        ORIGINAL_TEXTO_ACCION_COL_NAME: "texto_de_accion",
        ORIGINAL_TIPO_SERVICIO_COL_NAME: "tipo_de_servicio",
        ORIGINAL_COSTOS_COL_NAME: "costes_totreales",
        ORIGINAL_DESCRIPTION_COL_NAME: "descripcion",
        ORIGINAL_FECHA_AVISO_COL_NAME: "fecha_de_aviso",
        ORIGINAL_TEXTO_POSICION_COL_NAME: "texto_de_posicion",
        ORIGINAL_TEXTO_EQUIPO_COL_NAME: "texto_equipo",
        ORIGINAL_DURACION_PARADA_COL_NAME: "duracion_de_parada",
        ORIGINAL_EQUIPO_COL_NAME: "equipo",
        ORIGINAL_AVISO_COL_NAME: "aviso"
    }

    normalized_df_columns = []
    for col in df.columns:
        found_match = False
        for original, normalized in column_mapping.items():
            if col.strip().lower() == original.strip().lower():
                normalized_df_columns.append(normalized)
                found_match = True
                break
        if not found_match:
            normalized_df_columns.append(
                col.lower()
                .strip()
                .replace(" ", "_")
                .replace(".", "")
                .replace("á", "a").replace("é", "e").replace("í", "i").replace("ó", "o").replace("ú", "u")
            )
    df.columns = normalized_df_columns

    # Assign relevant columns to new, simplified names for easier access (from first code)
    df['PROVEEDOR'] = df['denominacion_ejecutante']
    df['COSTO'] = df['costes_totreales']
    df['TIEMPO PARADA'] = pd.to_numeric(df['duracion_de_parada'], errors='coerce')
    df['EQUIPO'] = pd.to_numeric(df['equipo'], errors='coerce')
    df['AVISO'] = pd.to_numeric(df['aviso'], errors='coerce')
    df['TIPO DE SERVICIO'] = df['tipo_de_servicio']

    # Ensure 'costes_totreales' is numeric
    df['costes_totreales'] = pd.to_numeric(df['costes_totreales'], errors='coerce')

    # --- HORARIO Mapping (from first code) ---
    horarios_dict = {
        "HORARIO_99": (17, 364.91), "HORARIO_98": (14.5, 312.78), "HORARIO_97": (9.818181818, 286.715),
        "HORARIO_96": (14.5, 312.78), "HORARIO_95": (4, 208.52), "HORARIO_93": (13.45454545, 286.715),
        "HORARIO_92": (6, 338.845), "HORARIO_91": (9.25, 312.78), "HORARIO_90": (11, 260.65),
        "HORARIO_9": (16, 312.78), "HORARIO_89": (9.5, 260.65), "HORARIO_88": (14, 260.65),
        "HORARIO_87": (9.333333333, 312.78), "HORARIO_86": (9.666666667, 312.78), "HORARIO_85": (12, 312.78),
        "HORARIO_84": (9.5, 312.78), "HORARIO_83": (8.416666667, 312.78), "HORARIO_82": (6, 312.78),
        "HORARIO_81": (10, 312.78), "HORARIO_80": (8.5, 312.78), "HORARIO_8": (11.6, 260.65),
        "HORARIO_79": (14, 312.78), "HORARIO_78": (12, 312.78), "HORARIO_77": (3, 312.78),
        "HORARIO_76": (16, 312.78), "HORARIO_75": (12.16666667, 312.78), "HORARIO_74": (11.33333333, 312.78),
        "HORARIO_73": (12.66666667, 312.78), "HORARIO_72": (11.83333333, 312.78), "HORARIO_71": (11, 312.78),
        "HORARIO_70": (15.16666667, 312.78), "HORARIO_7": (15.33333333, 312.78), "HORARIO_69": (9.166666667, 312.78),
        "HORARIO_68": (4, 312.78), "HORARIO_67": (10, 260.65), "HORARIO_66": (4, 260.65),
        "HORARIO_65": (16.76923077, 338.845), "HORARIO_64": (17.15384615, 338.845), "HORARIO_63": (22.5, 312.78),
        "HORARIO_62": (12.25, 312.78), "HORARIO_61": (4, 312.78), "HORARIO_60": (13, 312.78),
        "HORARIO_6": (18.46153846, 338.845), "HORARIO_59": (12.66666667, 312.78), "HORARIO_58": (12.33333333, 312.78),
        "HORARIO_57": (13.53846154, 338.845), "HORARIO_56": (12.16666667, 312.78), "HORARIO_55": (6.333333333, 312.78),
        "HORARIO_54": (7.230769231, 338.845), "HORARIO_53": (5.5, 312.78), "HORARIO_52": (4, 312.78),
        "HORARIO_51": (14, 338.845), "HORARIO_50": (15, 312.78), "HORARIO_5": (17, 312.78),
        "HORARIO_49": (15.27272727, 286.715), "HORARIO_48": (14.76923077, 338.845), "HORARIO_47": (14.5, 312.78),
        "HORARIO_46": (14.33333333, 312.78), "HORARIO_45": (14.16666667, 312.78), "HORARIO_44": (13.83333333, 312.78),
        "HORARIO_43": (13.5, 312.78), "HORARIO_42": (13.91666667, 312.78), "HORARIO_41": (15, 364.91),
        "HORARIO_40": (15.81818182, 286.715), "HORARIO_4": (16.16666667, 312.78), "HORARIO_39": (15.27272727, 286.715),
        "HORARIO_38": (13.84615385, 338.845), "HORARIO_37": (15.09090909, 286.715), "HORARIO_36": (14, 364.91),
        "HORARIO_35": (14.30769231, 338.845), "HORARIO_34": (14.90909091, 286.715), "HORARIO_33": (13.55, 312.78),
        "HORARIO_32": (14, 338.845), "HORARIO_31": (14.72727273, 286.715), "HORARIO_30": (13.08333333, 312.78),
        "HORARIO_3": (16, 312.78), "HORARIO_29": (14, 286.715), "HORARIO_28": (13, 364.91),
        "HORARIO_27": (14, 286.715), "HORARIO_26": (12.58333333, 312.78), "HORARIO_25": (12, 312.78),
        "HORARIO_24": (13.27272727, 286.715), "HORARIO_23": (11.83333333, 312.78), "HORARIO_22": (11.91666667, 312.78),
        "HORARIO_21": (13.09090909, 286.715), "HORARIO_20": (5, 312.78), "HORARIO_2": (23.5, 364.91),
        "HORARIO_19": (12.18181818, 286.715), "HORARIO_18": (5, 312.78), "HORARIO_17": (9.75, 312.78),
        "HORARIO_16": (10.36363636, 286.715), "HORARIO_15": (10.18181818, 286.715), "HORARIO_14": (8.5, 312.78),
        "HORARIO_134": (12, 364.91), "HORARIO_133": (12, 260.65), "HORARIO_132": (13, 312.78),
        "HORARIO_131": (10, 312.78), "HORARIO_130": (11, 260.65), "HORARIO_13": (9.454545455, 286.715),
        "HORARIO_129": (9.384615385, 338.845), "HORARIO_128": (12.33333333, 312.78), "HORARIO_127": (9.666666667, 312.78),
        "HORARIO_126": (10.83333333, 312.78), "HORARIO_125": (4, 312.78), "HORARIO_124": (13.66666667, 312.78),
        "HORARIO_123": (16.61538462, 338.845), "HORARIO_122": (11, 260.65), "HORARIO_121": (11.66666667, 312.78),
        "HORARIO_120": (8.25, 312.78), "HORARIO_12": (9.272727273, 286.715), "HORARIO_119": (11.23076923, 338.845),
        "HORARIO_118": (11.27272727, 286.715), "HORARIO_117": (11.41666667, 312.78), "HORARIO_116": (11, 312.78),
        "HORARIO_115": (9.25, 312.78), "HORARIO_114": (23.07692308, 338.845), "HORARIO_113": (20, 338.845),
        "HORARIO_112": (10.61538462, 338.845), "HORARIO_111": (9.454545455, 286.715), "HORARIO_110": (6.833333333, 312.78),
        "HORARIO_11": (8, 312.78), "HORARIO_109": (12.90909091, 286.715), "HORARIO_108": (10.54545455, 286.715),
        "HORARIO_107": (12.61538462, 338.845), "HORARIO_106": (14.76923077, 338.845), "HORARIO_105": (12, 156.39),
        "HORARIO_104": (7.666666667, 312.78), "HORARIO_103": (3, 260.65), "HORARIO_102": (10.16666667, 312.78),
        "HORARIO_101": (12, 260.65), "HORARIO_100": (11.16666667, 312.78), "HORARIO_10": (6, 312.78),
        "HORARIO_1": (24, 364.91),
    }
    df['HORARIO'] = df['texto_equipo'].str.strip().str.upper()
    df['HORA/ DIA'] = df['HORARIO'].map(lambda x: horarios_dict.get(x, (None, None))[0])
    df['DIAS/ AÑO'] = df['HORARIO'].map(lambda x: horarios_dict.get(x, (None, None))[1])
    df['DIAS/ AÑO'] = pd.to_numeric(df['DIAS/ AÑO'], errors='coerce')
    df['HORA/ DIA'] = pd.to_numeric(df['HORA/ DIA'], errors='coerce')

    # --- Initial Filtering from first code ---
    df = df.dropna(subset=['EQUIPO'])

    # --- Additional Preprocessing for Second Code's requirements ---
    df["fecha_de_aviso"] = pd.to_datetime(df["fecha_de_aviso"], errors="coerce")
    df["año"] = df["fecha_de_aviso"].dt.year
    df["mes"] = df["fecha_de_aviso"].dt.strftime("%B")

    def extract_description_category(description):
        if pd.isna(description):
            return "Otros"
        match = re.match(r'^([A-Z]{2})/', str(description).strip())
        if match:
            return match.group(1)
        return "Otros"

    df["description_category"] = df['descripcion'].apply(extract_description_category)
    return df

# --- DEFINICIÓN DE PREGUNTAS PARA EVALUACIÓN (from first code) ---
preguntas = [
    ("Calidad", "¿Las soluciones propuestas son coherentes con el diagnóstico y causa raíz del problema?", "2,1,0,-1"),
    ("Calidad", "¿El trabajo entregado tiene materiales nuevos, originales y de marcas reconocidas?", "2,1,0,-1"),
    ("Calidad", "¿Cuenta con acabados homogéneos, limpios y pulidos?", "2,1,0,-1"),
    ("Calidad", "¿El trabajo entregado corresponde completamente con lo contratado?", "2,1,0,-1"),
    ("Calidad", "¿La facturación refleja correctamente lo ejecutado y acordado?", "2,1,0,-1"),
    ("Oportunidad", "¿La entrega de cotizaciones fue oportuna, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿El reporte del servicio fue entregado oportunamente, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿Cumple las fechas y horas programadas para los trabajos, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿Responde de forma efectiva ante eventualidades emergentes, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿Soluciona rápidamente reclamos o inquietudes por garantía, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿Dispone de los repuestos requeridos en los tiempos necesarios, según el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¿Entrega las facturas en los tiempos convenidos, según el contrato?", "2,1,0,-1"),
    ("Precio", "¿Los precios ofrecidos para equipos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¿Los precios ofrecidos para repuestos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¿Los precios ofrecidos para mantenimientos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¿Los precios ofrecidos para insumos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Postventa", "¿Tiene disposición y actitud de servicio frente a solicitudes?", "2,1,0,-1"),
    ("Postventa", "¿Conoce necesidades y ofrece alternativas adecuadas?", "2,1,0,-1"),
    ("Postventa", "¿Realiza seguimiento a los resultados de los trabajos?", "2,1,0,-1"),
    ("Postventa", "¿Ofrece capacitaciones para el manejo de los equipos?", "2,1,0,-1"),
    ("Postventa", "¿Los métodos de capacitación ofrecidos son efectivos y adecuados?", "2,1,0,-1"),
    ("Desempeño técnico", "Disponibilidad promedio (%)", "auto"),
    ("Desempeño técnico", "MTTR promedio (hrs)", "auto"),
    ("Desempeño técnico", "MTBF promedio (hrs)", "auto"),
    ("Desempeño técnico", "Rendimiento promedio equipos", "auto"),
]

# --- FUNCIONES DE CÁLCULO DE INDICADORES (from first code) ---
def calcular_indicadores_servicio(df_sub):
    if df_sub.empty:
        return pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object)

    cnt = df_sub['TIPO DE SERVICIO'].value_counts()
    cost = df_sub.groupby('TIPO DE SERVICIO')['COSTO'].sum()
    mttr = df_sub.groupby('TIPO DE SERVICIO')['TIEMPO PARADA'].mean()

    ttot = df_sub.groupby('TIPO DE SERVICIO').apply(
        lambda g: (g['DIAS/ AÑO'].mean() * g['HORA/ DIA'].mean()) if not g['DIAS/ AÑO'].isnull().all() and not g['HORA/ DIA'].isnull().all() else np.nan
    )

    down = df_sub.groupby('TIPO DE SERVICIO')['TIEMPO PARADA'].sum()
    fails = df_sub.groupby('TIPO DE SERVICIO')['AVISO'].count()
    mtbf = (ttot - down) / fails.replace(0, np.nan)

    disp = (mtbf / (mtbf + mttr)).replace([np.inf, -np.inf], np.nan) * 100
    rend = disp.apply(lambda v: 'Alto' if v >= 90 else ('Medio' if v >= 75 else 'Bajo') if not pd.isna(v) else np.nan)
    return cnt, cost, mttr, mtbf, disp, rend

def calcular_indicadores_equipo(df_sub):
    if df_sub.empty:
        return pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object)

    cnt_equipo = df_sub['EQUIPO'].value_counts()
    cost_equipo = df_sub.groupby('EQUIPO')['COSTO'].sum()
    mttr_equipo = df_sub.groupby('EQUIPO')['TIEMPO PARADA'].mean()

    desc_category_equipo = df_sub.groupby('EQUIPO')['description_category'].first().fillna('Desconocido')

    ttot_equipo = df_sub.groupby('EQUIPO').apply(
        lambda g: (g['DIAS/ AÑO'].mean() * g['HORA/ DIA'].mean()) if not g['DIAS/ AÑO'].isnull().all() and not g['HORA/ DIA'].isnull().all() else np.nan
    )

    down_equipo = df_sub.groupby('EQUIPO')['TIEMPO PARADA'].sum()
    fails_equipo = df_sub.groupby('EQUIPO')['AVISO'].count()
    mtbf_equipo = (ttot_equipo - down_equipo) / fails_equipo.replace(0, np.nan)

    disp_equipo = (mtbf_equipo / (mtbf_equipo + mttr_equipo)).replace([np.inf, -np.inf], np.nan) * 100
    rend_equipo = disp_equipo.apply(lambda v: 'Alto' if v >= 90 else ('Medio' if v >= 75 else 'Bajo') if not pd.isna(v) else np.nan)
    return cnt_equipo, cost_equipo, mttr_equipo, mtbf_equipo, disp_equipo, rend_equipo, desc_category_equipo

# --- EVALUATION APP FOR STREAMLIT ---
class EvaluacionProveedoresApp:
    def __init__(self, df):
        self.df = df
        self.all_evaluation_widgets_map = {}
        self.summary_servicio_global_for_export = None
        self.resumen_equipo_global_for_export = None

    def display_evaluation_form(self, df_filtered, prov):
        st.subheader(f"Evaluación de Proveedor: {prov}")

        cnt_s, cost_s, mttr_s, mtbf_s, disp_s, rend_s = calcular_indicadores_servicio(df_filtered)
        st.session_state['current_provider_metrics'] = {'cnt': cnt_s, 'cost': cost_s, 'mttr': mttr_s, 'mtbf': mtbf_s, 'disp': disp_s, 'rend': rend_s}

        all_provider_service_types = sorted(df_filtered['TIPO DE SERVICIO'].dropna().unique().tolist())
        st.session_state['all_provider_service_types'] = all_provider_service_types
        st.session_state['all_evaluation_widgets_map'] = st.session_state.get('all_evaluation_widgets_map', {})

        if 'evaluation_page' not in st.session_state:
            st.session_state['evaluation_page'] = 0

        start_index = st.session_state['evaluation_page'] * 5
        end_index = min(start_index + 5, len(all_provider_service_types))
        service_types_on_page = all_provider_service_types[start_index:end_index]

        if not service_types_on_page:
            st.info("No hay tipos de servicio para mostrar en esta página.")
            return

        st.markdown("### Calificación de Preguntas por Tipo de Servicio")
        st.info("Utiliza los selectores para asignar una puntuación a cada pregunta por tipo de servicio.")

        # Display service type mapping for the current page
        with st.expander("Ver mapeo de Tipos de Servicio en esta página"):
            if service_types_on_page:
                for st_val in service_types_on_page:
                    idx = all_provider_service_types.index(st_val) + 1
                    st.write(f"Servicio {idx}: {st_val}")
            else:
                st.write("No hay tipos de servicio en esta página para mapear.")

        col_questions, *col_services = st.columns([0.4] + [0.15] * len(service_types_on_page))

        with col_questions:
            st.write("**Pregunta**")
        for i, st_label in enumerate(service_types_on_page):
            with col_services[i]:
                global_idx = all_provider_service_types.index(st_label) + 1
                st.write(f"**Servicio {global_idx} ({st_label})**")

        for cat, texto, escala in preguntas:
            with col_questions:
                st.markdown(f"**[{cat}]** {texto}")

            for i, st_original in enumerate(service_types_on_page):
                with col_services[i]:
                    unique_key = f"{cat}-{texto}-{st_original}"
                    if escala == "auto":
                        val = 0
                        metrics = st.session_state['current_provider_metrics']
                        disp = metrics.get('disp', pd.Series())
                        mttr = metrics.get('mttr', pd.Series())
                        mtbf = metrics.get('mtbf', pd.Series())
                        rend = metrics.get('rend', pd.Series())

                        if 'Disponibilidad' in texto and st_original in disp and not pd.isna(disp[st_original]):
                            mean_disp = disp[st_original]
                            val = 2 if mean_disp >= 98 else (1 if mean_disp >= 75 else 0)
                        elif 'MTTR' in texto and st_original in mttr and not pd.isna(mttr[st_original]):
                            mean_mttr = mttr[st_original]
                            val = 2 if mean_mttr <= 5 else (1 if mean_mttr <= 20 else 0)
                        elif 'MTBF' in texto and st_original in mtbf and not pd.isna(mtbf[st_original]):
                            mean_mtbf = mtbf[st_original]
                            val = 2 if mean_mtbf > 1000 else (1 if mean_mtbf >= 100 else 0)
                        elif 'Rendimiento' in texto and st_original in rend and not pd.isna(rend[st_original]):
                            perf_class = rend[st_original]
                            if perf_class == 'Alto':
                                val = 2
                            elif perf_class == 'Medio':
                                val = 1
                            elif perf_class == 'Bajo':
                                val = 0
                        st.write(str(val))
                        st.session_state['all_evaluation_widgets_map'][unique_key] = val # Store fixed value
                    else:
                        opts = {'Sobresaliente (2)': 2, 'Bueno (1)': 1, 'Indiferente (0)': 0, 'Malo (-1)': -1}
                        current_value = st.session_state['all_evaluation_widgets_map'].get(unique_key, 0)
                        selected_option = st.selectbox(
                            label=" ",
                            options=list(opts.keys()),
                            format_func=lambda x: x.split(' ')[0], # Display only the rating word
                            key=unique_key,
                            index=list(opts.values()).index(current_value) if current_value in list(opts.values()) else 2 # Default to Indiferente (0)
                        )
                        st.session_state['all_evaluation_widgets_map'][unique_key] = opts[selected_option]

        col1, col2 = st.columns([1,1])
        with col1:
            if st.button("Anterior", key="prev_eval_page", disabled=(st.session_state['evaluation_page'] == 0)):
                st.session_state['evaluation_page'] -= 1
                st.experimental_rerun()
        with col2:
            if st.button("Siguiente", key="next_eval_page", disabled=(end_index >= len(all_provider_service_types))):
                st.session_state['evaluation_page'] += 1
                st.experimental_rerun()

        st.markdown("---")
        if st.button("Generar Resumen de Evaluación y Exportar a Excel"):
            self.generar_resumen_evaluacion(df_filtered)

        # Plotting if metrics are available
        metrics = st.session_state.get('current_provider_metrics', {})
        rend_data = metrics.get('rend', pd.Series())
        mttr_data = metrics.get('mttr', pd.Series())
        mtbf_data = metrics.get('mtbf', pd.Series())
        disp_data = metrics.get('disp', pd.Series())

        if not rend_data.empty:
            self.graficar_rendimiento(rend_data)
        else:
            st.info("No hay datos de rendimiento para graficar.")

        if not mttr_data.empty or not mtbf_data.empty or not disp_data.empty:
            self.graficar_resumen(mttr_data, mtbf_data, disp_data)
        else:
            st.info("No hay datos de MTTR, MTBF o Disponibilidad para graficar.")

    def generar_resumen_evaluacion(self, df_filtered):
        st.subheader("Generando resumen de evaluación...")

        if not st.session_state.get('all_evaluation_widgets_map'):
            st.warning("No hay evaluaciones para resumir. Selecciona un proveedor y completa las evaluaciones.")
            return

        all_provider_service_types = st.session_state.get('all_provider_service_types', [])
        unique_service_types = sorted(list(set([key.split('-')[2] for key in st.session_state['all_evaluation_widgets_map'].keys()])))

        all_categories = sorted(list(set([p[0] for p in preguntas])))
        category_service_scores = {cat: {st_val: 0 for st_val in unique_service_types} for cat in all_categories}
        service_type_totals = {st_val: 0 for st_val in unique_service_types}

        for unique_key, score in st.session_state['all_evaluation_widgets_map'].items():
            try:
                cat, q_text, st_original = unique_key.split('-', 2)
                category_service_scores[cat][st_original] += score
                service_type_totals[st_original] += score
            except ValueError:
                st.warning(f"Advertencia: No se pudo obtener la puntuación para el key '{unique_key}'. Asegúrate de que el valor sea numérico.")
            except KeyError:
                st.warning(f"Advertencia: Categoría '{cat}' o tipo de servicio '{st_original}' no encontrado en la estructura de puntuación.")

        summary_df_calificacion = pd.DataFrame.from_dict(category_service_scores, orient='index')
        summary_df_calificacion.index.name = 'Categoría'
        summary_df_calificacion.loc['Total por Calificación de Servicio'] = pd.Series(service_type_totals)

        service_type_display_names_cal = {st_val: f"Servicio {all_provider_service_types.index(st_val) + 1} ({st_val})"
                                          for st_val in unique_service_types if st_val in all_provider_service_types}
        for st_val in unique_service_types:
            if st_val not in all_provider_service_types:
                service_type_display_names_cal[st_val] = f"Servicio Nuevo ({st_val})"

        summary_df_calificacion = summary_df_calificacion.rename(columns=service_type_display_names_cal)
        summary_df_calificacion.columns.name = 'Tipo de Servicio'

        prov_name = st.session_state['selected_provider'].replace(" ", "_").replace("/", "-")
        output_filename = f"resumen_evaluacion_{prov_name}.xlsx"

        # Prepare metrics for export
        metrics = st.session_state.get('current_provider_metrics', {})
        cnt_s = metrics.get('cnt', pd.Series())
        cost_s = metrics.get('cost', pd.Series())
        mttr_s = metrics.get('mttr', pd.Series())
        mtbf_s = metrics.get('mtbf', pd.Series())
        disp_s = metrics.get('disp', pd.Series())
        rend_s = metrics.get('rend', pd.Series())

        summary_servicio_export = pd.DataFrame({
            'Cantidad de Avisos': cnt_s,
            'Costo Total': cost_s,
            'Disponibilidad (%)': disp_s.round(2) if not disp_s.empty else np.nan,
            'MTTR (hrs)': mttr_s.round(2) if not mttr_s.empty else np.nan,
            'MTBF (hrs)': mtbf_s.round(2) if not mtbf_s.empty else np.nan,
            'Rendimiento': rend_s
        }).reset_index().rename(columns={'index': 'TIPO DE SERVICIO'}).sort_values('Disponibilidad (%)', ascending=False)
        for col in ['Disponibilidad (%)', 'MTTR (hrs)', 'MTBF (hrs)']:
            if col in summary_servicio_export.columns:
                summary_servicio_export[col] = summary_servicio_export[col].fillna(0)

        cnt_e, cost_e, mttr_e, mtbf_e, disp_e, rend_e, desc_category_e = calcular_indicadores_equipo(df_filtered)
        resumen_equipo_export = pd.DataFrame({
            'Avisos': cnt_e,
            'Costo total': cost_e,
            'MTTR': mttr_e.round(2) if not mttr_e.empty else np.nan,
            'MTBF': mtbf_e.round(2) if not mtbf_e.empty else np.nan,
            'Disponibilidad (%)': disp_e.round(2) if not disp_e.empty else np.nan,
            'Rendimiento': rend_e,
            'Categoría de Descripción': desc_category_e
        }).reset_index().rename(columns={'index': 'Denominacion'})
        for col in ['Disponibilidad (%)', 'MTTR', 'MTBF']:
            if col in resumen_equipo_export.columns:
                resumen_equipo_export[col] = resumen_equipo_export[col].fillna(0)

        # Create an in-memory Excel file
        excel_buffer = io.BytesIO()
        with pd.ExcelWriter(excel_buffer, engine='xlsxwriter') as writer:
            if not summary_servicio_export.empty:
                summary_servicio_export.to_excel(writer, sheet_name='Resumen_Servicio', index=False)
            else:
                st.warning("No se encontró la tabla de resumen por Tipo de Servicio para exportar o está vacía.")

            if not resumen_equipo_export.empty:
                resumen_equipo_export.to_excel(writer, sheet_name='Resumen_Equipo', index=False)
            else:
                st.warning("No se encontró la tabla de resumen por Equipo para exportar o está vacía.")

            if not summary_df_calificacion.empty:
                summary_df_calificacion.to_excel(writer, sheet_name='Resumen_Calificacion')
            else:
                 st.warning("No se encontró la tabla de resumen de Calificación para exportar o está vacía.")

        excel_buffer.seek(0) # Rewind the buffer before sending it
        st.download_button(
            label="Descargar Resumen de Evaluación (Excel)",
            data=excel_buffer,
            file_name=output_filename,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help="Descarga el resumen de evaluación en formato XLSX."
        )
        st.success(f"Resumen de evaluación generado y listo para descargar.")


    def graficar_rendimiento(self, rend):
        if rend.empty:
            st.info("No hay datos de rendimiento para graficar.")
            return

        rend_filtered = rend.dropna()
        if rend_filtered.empty:
            st.info("No hay datos de rendimiento válidos para graficar después de eliminar NaNs.")
            return

        rend_counts = rend_filtered.value_counts().reindex(['Alto', 'Medio', 'Bajo'], fill_value=0)

        if rend_counts.sum() > 0:
            colores = ['#66bb6a', '#ffee58', '#ef5350']
            active_colors = [color for i, color in enumerate(colores) if rend_counts.iloc[i] > 0]
            labels = [f'{idx} ({val}%)' for idx, val in rend_counts.items() if val > 0]
            sizes = [val for val in rend_counts.values if val > 0]

            if not sizes:
                st.info("No hay datos de rendimiento para mostrar en el gráfico de pastel.")
                return

            fig_pie, ax_pie = plt.subplots(figsize=(6, 6))
            wedges, texts, autotexts = ax_pie.pie(sizes, autopct='%1.1f%%', colors=active_colors, startangle=90, counterclock=False, pctdistance=0.85)
            ax_pie.set_title('Distribución Rendimiento por Tipo de Servicio')
            ax_pie.set_ylabel('')
            ax_pie.axis('equal')
            st.pyplot(fig_pie)
        else:
            st.info("No hay datos válidos de rendimiento para graficar.")

    def graficar_resumen(self, mttr, mtbf, disp):
        plots_to_make = 0
        if not mttr.dropna().empty: plots_to_make += 1
        if not mtbf.dropna().empty: plots_to_make += 1
        if not disp.dropna().empty: plots_to_make += 1

        if plots_to_make == 0:
            st.info("No hay datos de MTTR, MTBF o Disponibilidad para graficar.")
            return

        fig_hist, axs = plt.subplots(1, plots_to_make, figsize=(5 * plots_to_make, 4))
        if plots_to_make == 1:
            axs = [axs]

        plot_idx = 0
        if not mttr.dropna().empty:
            sns.histplot(mttr.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='skyblue')
            axs[plot_idx].set_title('MTTR Promedio por Servicio (hrs)')
            plot_idx += 1
        if not mtbf.dropna().empty:
            sns.histplot(mtbf.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='lightgreen')
            axs[plot_idx].set_title('MTBF Promedio por Servicio (hrs)')
            plot_idx += 1
        if not disp.dropna().empty:
            sns.histplot(disp.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='salmon')
            axs[plot_idx].set_title('Disponibilidad Promedio por Servicio (%)')
            plot_idx += 1

        plt.tight_layout()
        st.pyplot(fig_hist)


# --- COST AND NOTICE ANALYSIS APP FOR STREAMLIT ---
class CostosAvisosApp:
    def __init__(self, df):
        self.df = df
        self.EJECUTANTE_COL_NAME_NORMALIZED = "denominacion_ejecutante"
        self.COL_COSTOS_NORMALIZED = "costes_totreales"
        self.CP_COL_NAME_NORMALIZED = "codigo_postal"
        self.DESCRIPTION_COL_NAME_NORMALIZED = "descripcion"

        # Ensure filters use only valid options from the DataFrame
        self.ejecutantes = sorted(self.df[self.EJECUTANTE_COL_NAME_NORMALIZED].dropna().unique().tolist())
        self.cps = sorted(self.df[self.CP_COL_NAME_NORMALIZED].dropna().unique().tolist())
        self.años = sorted(self.df["año"].dropna().unique().tolist())
        self.meses = sorted(self.df["mes"].dropna().unique().tolist(), key=lambda x: pd.to_datetime(x, format="%B").month)

        self.opciones_menu = {
            "Costos por ejecutante": (self.EJECUTANTE_COL_NAME_NORMALIZED, self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por ejecutante": (self.EJECUTANTE_COL_NAME_NORMALIZED, None, "avisos"),
            "Costos por objeto técnico": ("denominacion_de_objeto_tecnico", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por objeto técnico": ("denominacion_de_objeto_tecnico", None, "avisos"),
            "Costos por texto código acción": ("texto_codigo_accion", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por texto código acción": ("texto_codigo_accion", None, "avisos"),
            "Costos por texto de acción": ("texto_de_accion", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por texto de acción": ("texto_de_accion", None, "avisos"),
            "Costos por tipo de servicio": ("tipo_de_servicio", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por tipo de servicio": ("tipo_de_servicio", None, "avisos"),
            "Costos por categoría de descripción": ("description_category", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por categoría de descripción": ("description_category", None, "avisos"),
        }

        if 'costos_page' not in st.session_state:
            st.session_state['costos_page'] = 0
        if 'current_grouped_data' not in st.session_state:
            st.session_state['current_grouped_data'] = pd.Series()
        if 'selected_costos_option' not in st.session_state:
            st.session_state['selected_costos_option'] = list(self.opciones_menu.keys())[0]

    def formato_coste(self, valor):
        if pd.isna(valor):
            return "$ N/A"
        return f"$ {valor:,.0f}COP".replace(",", ".")

    def custom_cost_formatter(self, x, pos):
        if x >= 1e9:
            return f"${x*1e-9:.0f}B"
        elif x >= 1e6:
            return f"${x*1e-6:.0f}M"
        elif x >= 1e3:
            return f"${x*1e-3:.0f}K"
        else:
            return f"${x:.0f}"

    def plot_points_with_labels(self, data, title, xlabel="", ylabel="", color="skyblue", rotation=45):
        if data.empty:
            st.info(f"No hay datos para graficar: {title}")
            return

        fig, ax = plt.subplots(figsize=(12, 6))
        x_labels = data.index.astype(str)
        x_positions = np.arange(len(data))

        ax.scatter(x_positions, data.values, color=color, zorder=2)

        for i, txt in enumerate(data.values):
            if "avisos" in title.lower():
                label_text = f"{int(txt):,}".replace(",", ".")
            else:
                label_text = self.custom_cost_formatter(txt, None)
            ax.text(x_positions[i], txt, label_text, ha='center', va='bottom', fontsize=9, color='black')

        ax.set_title(title)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.set_xticks(x_positions)
        ax.set_xticklabels(x_labels, rotation=rotation, ha="right")

        if "costos" in title.lower():
            ax.yaxis.set_major_formatter(plt.FuncFormatter(self.custom_cost_formatter))

        ax.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        st.pyplot(fig)


    def display_costos_avisos_app(self):
        st.subheader("Análisis de Costos y Avisos")

        col1, col2 = st.columns(2)
        with col1:
            selected_ejecutantes = st.multiselect("Ejecutante", options=self.ejecutantes, default=self.ejecutantes)
        with col2:
            selected_cps = st.multiselect("Código postal", options=self.cps, default=self.cps)

        col3, col4 = st.columns(2)
        with col3:
            selected_año = st.selectbox("Año", options=["Todos"] + self.años, index=0)
        with col4:
            selected_mes = st.selectbox("Mes", options=["Todos"] + self.meses, index=0)

        selected_option = st.selectbox(
            "Ver:",
            options=list(self.opciones_menu.keys()),
            key="costos_menu_select",
            on_change=self._reset_costos_page,
            args=(selected_ejecutantes, selected_cps, selected_año, selected_mes) # Pass current filters to on_change
        )
        st.session_state['selected_costos_option'] = selected_option

        # Filter data based on selections
        df_filtered = self.df.copy()
        if selected_ejecutantes:
            df_filtered = df_filtered[df_filtered[self.EJECUTANTE_COL_NAME_NORMALIZED].isin(selected_ejecutantes)]
        if selected_cps:
            df_filtered = df_filtered[df_filtered[self.CP_COL_NAME_NORMALIZED].isin(selected_cps)]
        if selected_año != "Todos":
            df_filtered = df_filtered[df_filtered["año"] == selected_año]
        if selected_mes != "Todos":
            df_filtered = df_filtered[df_filtered["mes"] == selected_mes]

        if df_filtered.empty:
            st.info("No hay datos que coincidan con los filtros seleccionados.")
            st.session_state['current_grouped_data'] = pd.Series()
            return

        col, col_cost, tipo = self.opciones_menu[selected_option]

        if col not in df_filtered.columns:
            st.error(f"Error: La columna '{col}' no se encontró en los datos filtrados. Columnas disponibles: {df_filtered.columns.tolist()}")
            st.session_state['current_grouped_data'] = pd.Series()
            return

        if tipo == "costos":
            if col_cost not in df_filtered.columns:
                st.error(f"Error: La columna de costos '{col_cost}' no se encontró en los datos filtrados.")
                st.session_state['current_grouped_data'] = pd.Series()
                return
            grouped_data = df_filtered.groupby(col)[col_cost].sum().sort_values(ascending=False)
        else:
            grouped_data = df_filtered[col].value_counts().sort_values(ascending=False)

        st.session_state['current_grouped_data'] = grouped_data

        if grouped_data.empty:
            st.info(f"No hay datos para mostrar para la opción '{selected_option}' con los filtros actuales.")
            return

        # Pagination logic
        items_per_page = 20
        total_items = len(grouped_data)
        max_page = max(0, (total_items - 1) // items_per_page)

        st.session_state['costos_page'] = min(st.session_state['costos_page'], max_page) # Adjust page if filters change data size

        start_idx = st.session_state['costos_page'] * items_per_page
        end_idx = min(start_idx + items_per_page, total_items)
        data_to_display = grouped_data.iloc[start_idx:end_idx]

        st.markdown(f"### Resultados ({selected_option}) - Página {st.session_state['costos_page'] + 1} de {max_page + 1}")

        # Display table
        if tipo == "costos":
            df_table = data_to_display.apply(self.formato_coste).to_frame().reset_index()
            df_table.columns = [col.replace("_", " ").title() for col in df_table.columns] # Prettify column names
        else:
            df_table = data_to_display.to_frame().reset_index()
            df_table.columns = [col.replace("_", " ").title() for col in df_table.columns] # Prettify column names
        st.dataframe(df_table, use_container_width=True)

        # Pagination buttons
        col_prev, col_next = st.columns([1,1])
        with col_prev:
            if st.button("← Página anterior", key="costos_prev_page", disabled=(st.session_state['costos_page'] == 0)):
                st.session_state['costos_page'] -= 1
                st.experimental_rerun()
        with col_next:
            if st.button("Página siguiente →", key="costos_next_page", disabled=(st.session_state['costos_page'] >= max_page)):
                st.session_state['costos_page'] += 1
                st.experimental_rerun()

        # Display plot
        self.plot_points_with_labels(data_to_display,
                                     f"{selected_option} - Página {st.session_state['costos_page'] + 1} de {max_page + 1}",
                                     xlabel=col.replace("_", " ").title(),
                                     ylabel="Costo Total (COP)" if tipo == "costos" else "Número de Avisos")

    def _reset_costos_page(self, *args):
        st.session_state['costos_page'] = 0


# --- Main Application Logic ---
st.title("¡Hola, usuario Sura! 👋")
st.markdown("---")
st.header("Proyecto de **Gerencia de Gestión Administrativa** en Ingeniería Clínica")
st.markdown("""
    Aquí podrás **analizar y gestionar los datos de avisos** para optimizar los procesos.
    Por favor, **sube el archivo `DATA2.XLSX`** para comenzar.
""")

uploaded_file = st.file_uploader("Sube tu archivo 'DATA2.XLSX' aquí", type=["xlsx"])

if uploaded_file:
    file_buffer = io.BytesIO(uploaded_file.getvalue())

    with st.spinner('Cargando y procesando datos... Esto puede tomar un momento.'):
        try:
            df = load_and_merge_data(file_buffer)

            # Eliminar registros cuyo 'Status del sistema' contenga "PTBO"
            initial_rows = len(df)
            df = df[~df["status_del_sistema"].str.contains("PTBO", case=False, na=False)]
            st.info(f"Se eliminaron {initial_rows - len(df)} registros con 'PTBO' en 'Status del sistema'.")

            # Dejar solo una fila con coste por cada aviso
            df['costes_totreales'] = df.groupby('aviso')['costes_totreales'].transform(
                lambda x: [x.iloc[0]] + [0]*(len(x)-1)
            )
            df['COSTO'] = df['costes_totreales'] # Update the 'COSTO' column as well

            st.success("✅ Datos cargados y procesados exitosamente.")
            st.write(f"**Filas finales:** {len(df)} – **Columnas:** {len(df.columns)}")

            st.markdown("---")
            st.subheader("Vista previa de los datos procesados:")
            st.dataframe(df.head(10))

            st.markdown("---")
            st.subheader("Descarga de Datos Procesados")

            csv_output = df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="Descargar como CSV",
                data=csv_output,
                file_name="avisos_filtrados.csv",
                mime="text/csv",
                help="Descarga el archivo en formato CSV."
            )

            excel_buffer_download = io.BytesIO()
            df.to_excel(excel_buffer_download, index=False, engine='openpyxl')
            excel_buffer_download.seek(0)
            st.download_button(
                label="Descargar como Excel",
                data=excel_buffer_download,
                file_name="avisos_filtrados.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                help="Descarga el archivo en formato XLSX."
            )

            st.markdown("---")
            st.success("¡El procesamiento ha finalizado! Ahora puedes descargar tus datos o seguir explorando.")

            # Initialize session state for app navigation
            if 'app_mode' not in st.session_state:
                st.session_state['app_mode'] = 'main_menu'

            evaluacion_app = EvaluacionProveedoresApp(df)
            costos_avisos_app = CostosAvisosApp(df)

            # Main menu in sidebar
            with st.sidebar:
                st.header("Menú Principal")
                if st.button("Evaluación de Proveedores", key="menu_evaluacion"):
                    st.session_state['app_mode'] = 'evaluacion'
                    st.session_state['evaluation_page'] = 0 # Reset evaluation page on menu click
                    st.session_state['all_evaluation_widgets_map'] = {} # Reset evaluations
                    st.session_state['current_provider_metrics'] = {}
                if st.button("Análisis de Costos y Avisos", key="menu_costos"):
                    st.session_state['app_mode'] = 'costos_avisos'
                    st.session_state['costos_page'] = 0 # Reset costos page on menu click

            if st.session_state['app_mode'] == 'main_menu':
                st.info("Selecciona una opción del menú lateral para comenzar.")
            elif st.session_state['app_mode'] == 'evaluacion':
                st.sidebar.markdown("---")
                st.sidebar.button("Volver al Menú Principal", key="back_to_main_eval", on_click=lambda: st.session_state.update({'app_mode': 'main_menu', 'evaluation_page': 0}))

                st.header("Evaluación de Proveedores")
                providers = ["Todos"] + sorted(df['PROVEEDOR'].dropna().unique().tolist())
                selected_provider = st.selectbox("Selecciona un Proveedor", providers, key="provider_select")
                st.session_state['selected_provider'] = selected_provider

                if selected_provider == "Todos":
                    df_to_evaluate = df.copy()
                else:
                    df_to_evaluate = df[df['PROVEEDOR'] == selected_provider].copy()

                if df_to_evaluate.empty:
                    st.warning(f"No hay datos disponibles para el proveedor '{selected_provider}'.")
                    st.session_state['all_evaluation_widgets_map'] = {}
                else:
                    evaluacion_app.display_evaluation_form(df_to_evaluate, selected_provider)

            elif st.session_state['app_mode'] == 'costos_avisos':
                st.sidebar.markdown("---")
                st.sidebar.button("Volver al Menú Principal", key="back_to_main_costos", on_click=lambda: st.session_state.update({'app_mode': 'main_menu', 'costos_page': 0}))
                costos_avisos_app.display_costos_avisos_app()


        except Exception as e:
            st.error(f"❌ ¡Ups! Ocurrió un error al procesar el archivo: {e}")
            st.warning("Por favor, verifica que el archivo subido sea `DATA2.XLSX` y tenga el formato de hojas esperado.")
            st.exception(e)
else:
    st.info("⬆️ Sube tu archivo `DATA2.XLSX` para empezar con el análisis.")
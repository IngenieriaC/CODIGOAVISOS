# -*- coding: utf-8 -*-
"""code_avisos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Muqw1oykoxweSm1oapspkUwdGxE60Pw
"""

# -*- coding: utf-8 -*-
"""avisos_integrado

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0ucN4kG4Y3v2ym3Sdye9h_33n32RKUH
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re
import io
import numpy as np

# Set a nice style for plots
sns.set_style('whitegrid')

# --- Configuraci√≥n de la p√°gina (tem√°tica Sura) ---
st.set_page_config(
    page_title="Gerencia de Gesti√≥n Administrativa - Sura",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Estilos CSS para ambientar en amarillo, blanco y azul rey
st.markdown(
    """
    <style>
    /* Estilos generales del fondo con degradado */
    .stApp {
        background: linear-gradient(to right, #FFFFFF, #FFFACD, #4169E1); /* Blanco, Amarillo claro (Cream), Azul Rey */
        color: #333333; /* Color de texto general */
    }
    /* Sidebar */
    .st-emotion-cache-1oe6z58 { /* Esta clase puede cambiar en futuras versiones de Streamlit */
        background-color: #F0F8FF; /* Azul claro para la sidebar */
    }
    /* T√≠tulos */
    h1, h2, h3, h4, h5, h6 {
        color: #4169E1; /* Azul Rey para los t√≠tulos */
    }
    /* Botones */
    .stButton>button {
        background-color: #4169E1; /* Azul Rey para los botones */
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.3s ease;
    }
    .stButton>button:hover {
        background-color: #F8D568; /* Amarillo para hover */
        color: #4169E1;
        border: 1px solid #4169E1;
    }
    /* Contenedores de contenido principal */
    .st-emotion-cache-z5fcl4, .st-emotion-cache-1c7y2kl, .st-emotion-cache-nahz7x { /* Clases gen√©ricas para contenedores */
        background-color: rgba(255, 255, 255, 0.9); /* Blanco semitransparente */
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
    }
    /* Mejoras para la tabla (dataframe) */
    .streamlit-dataframe {
        border-radius: 0.5rem;
        overflow: hidden; /* Asegura que las esquinas redondeadas se apliquen bien */
    }
    </style>
    """,
    unsafe_allow_html=True
)

# --- Funci√≥n de carga & uni√≥n (optimizada para Streamlit) ---
@st.cache_data
def load_and_merge_data(uploaded_file_buffer: io.BytesIO) -> pd.DataFrame:
    """
    Carga y fusiona los datos de las diferentes hojas de un archivo Excel.

    Args:
        uploaded_file_buffer (io.BytesIO): Buffer del archivo Excel subido por el usuario.

    Returns:
        pd.DataFrame: El DataFrame combinado y limpio.
    """
    # Cargar hojas directamente desde el buffer
    iw29 = pd.read_excel(uploaded_file_buffer, sheet_name=0)
    uploaded_file_buffer.seek(0) # Rebobinar el buffer para leer la siguiente hoja
    iw39 = pd.read_excel(uploaded_file_buffer, sheet_name=1)
    uploaded_file_buffer.seek(0)
    ih08 = pd.read_excel(uploaded_file_buffer, sheet_name=2)
    uploaded_file_buffer.seek(0)
    iw65 = pd.read_excel(uploaded_file_buffer, sheet_name=3)
    uploaded_file_buffer.seek(0)
    zpm015 = pd.read_excel(uploaded_file_buffer, sheet_name=4)

    # Limpiar encabezados
    for df_temp in (iw29, iw39, ih08, iw65, zpm015):
        df_temp.columns = df_temp.columns.str.strip()

    # Guardar "Equipo" original desde IW29 para evitar p√©rdida
    equipo_original = iw29[["Aviso", "Equipo", "Duraci√≥n de parada", "Descripci√≥n"]].copy()

    # Extraer solo columnas necesarias de iw39 para el merge (incluyendo 'Total general (real)')
    iw39_subset = iw39[["Aviso", "Total general (real)"]]

    # Unir por 'Aviso'
    tmp1 = pd.merge(iw29, iw39_subset, on="Aviso", how="left")
    tmp2 = pd.merge(tmp1, iw65, on="Aviso", how="left")

    # Restaurar el valor original de "Equipo" de IW29 despu√©s del merge
    tmp2.drop(columns=["Equipo"], errors='ignore', inplace=True)
    tmp2 = pd.merge(tmp2, equipo_original, on="Aviso", how="left")

    # Unir por 'Equipo' con IH08
    tmp3 = pd.merge(tmp2, ih08[[
        "Equipo", "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto", "Indicador ABC", "Denominaci√≥n de objeto t√©cnico"
    ]], on="Equipo", how="left")

    # Unir por 'Equipo' con ZPM015
    tmp4 = pd.merge(tmp3, zpm015[["Equipo", "TIPO DE SERVICIO"]], on="Equipo", how="left")

    # Renombrar columnas
    tmp4.rename(columns={
        "Texto": "Texto_equipo",
        "Total general (real)": "Costes tot.reales"
    }, inplace=True)

    columnas_finales = [
        "Aviso", "Orden", "Fecha de aviso", "C√≥digo postal", "Status del sistema",
        "Descripci√≥n", "Ubicaci√≥n t√©cnica", "Indicador", "Equipo",
        "Denominaci√≥n de objeto t√©cnico", "Denominaci√≥n ejecutante",
        "Duraci√≥n de parada", "Centro de coste", "Costes tot.reales",
        "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto_equipo",
        "Indicador ABC", "Texto c√≥digo acci√≥n", "Texto de acci√≥n",
        "Texto grupo acci√≥n", "TIPO DE SERVICIO"
    ]

    # Filtrar solo las columnas que realmente existen en tmp4
    columnas_finales = [col for col in columnas_finales if col in tmp4.columns]

    df = tmp4[columnas_finales]

    # Normalize column names more robustly from code_avisos (1).py
    ORIGINAL_EJECUTANTE_COL_NAME = "Denominaci√≥n ejecutante"
    ORIGINAL_CP_COL_NAME = "C√≥digo postal"
    ORIGINAL_OBJETO_TECNICO_COL_NAME = "Denominaci√≥n de objeto t√©cnico"
    ORIGINAL_TEXTO_CODIGO_ACCION_COL_NAME = "Texto c√≥digo acci√≥n"
    ORIGINAL_TEXTO_ACCION_COL_NAME = "Texto de acci√≥n"
    ORIGINAL_TIPO_SERVICIO_COL_NAME = "Tipo de servicio"
    ORIGINAL_COSTOS_COL_NAME = "Costes tot.reales"
    ORIGINAL_DESCRIPTION_COL_NAME = "Descripci√≥n"
    ORIGINAL_FECHA_AVISO_COL_NAME = "Fecha de aviso"
    ORIGINAL_TEXTO_POSICION_COL_NAME = "Texto de Posici√≥n" # This is the missing column
    ORIGINAL_TEXTO_EQUIPO_COL_NAME = "Texto_equipo"
    ORIGINAL_DURACION_PARADA_COL_NAME = "Duraci√≥n de parada"
    ORIGINAL_EQUIPO_COL_NAME = "Equipo"
    ORIGINAL_AVISO_COL_NAME = "Aviso"

    column_mapping = {
        ORIGINAL_EJECUTANTE_COL_NAME: "denominacion_ejecutante",
        ORIGINAL_CP_COL_NAME: "codigo_postal",
        ORIGINAL_OBJETO_TECNICO_COL_NAME: "denominacion_de_objeto_tecnico",
        ORIGINAL_TEXTO_CODIGO_ACCION_COL_NAME: "texto_codigo_accion",
        ORIGINAL_TEXTO_ACCION_COL_NAME: "texto_de_accion",
        ORIGINAL_TIPO_SERVICIO_COL_NAME: "tipo_de_servicio",
        ORIGINAL_COSTOS_COL_NAME: "costes_totreales",
        ORIGINAL_DESCRIPTION_COL_NAME: "descripcion",
        ORIGINAL_FECHA_AVISO_COL_NAME: "fecha_de_aviso",
        ORIGINAL_TEXTO_POSICION_COL_NAME: "texto_de_posicion",
        ORIGINAL_TEXTO_EQUIPO_COL_NAME: "texto_equipo",
        ORIGINAL_DURACION_PARADA_COL_NAME: "duracion_de_parada",
        ORIGINAL_EQUIPO_COL_NAME: "equipo",
        ORIGINAL_AVISO_COL_NAME: "aviso"
    }

    normalized_df_columns = []
    for col in df.columns:
        found_match = False
        for original, normalized in column_mapping.items():
            if col.strip().lower() == original.strip().lower():
                normalized_df_columns.append(normalized)
                found_match = True
                break
        if not found_match:
            normalized_df_columns.append(
                col.lower()
                .strip()
                .replace(" ", "_")
                .replace(".", "")
                .replace("√°", "a").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√∫", "u")
            )
    df.columns = normalized_df_columns

    # Assign relevant columns to new, simplified names for easier access (from first code)
    df['PROVEEDOR'] = df['denominacion_ejecutante']
    df['COSTO'] = df['costes_totreales']
    df['TIEMPO PARADA'] = pd.to_numeric(df['duracion_de_parada'], errors='coerce')
    df['EQUIPO'] = pd.to_numeric(df['equipo'], errors='coerce')
    df['AVISO'] = pd.to_numeric(df['aviso'], errors='coerce')
    df['TIPO DE SERVICIO'] = df['tipo_de_servicio']

    # Ensure 'costes_totreales' is numeric
    df['costes_totreales'] = pd.to_numeric(df['costes_totreales'], errors='coerce')

    # --- HORARIO Mapping (from first code) ---
    horarios_dict = {
        "HORARIO_99": (17, 364.91), "HORARIO_98": (14.5, 312.78), "HORARIO_97": (9.818181818, 286.715),
        "HORARIO_96": (14.5, 312.78), "HORARIO_95": (4, 208.52), "HORARIO_93": (13.45454545, 286.715),
        "HORARIO_92": (6, 338.845), "HORARIO_91": (9.25, 312.78), "HORARIO_90": (11, 260.65),
        "HORARIO_9": (16, 312.78), "HORARIO_89": (9.5, 260.65), "HORARIO_88": (14, 260.65),
        "HORARIO_87": (9.333333333, 312.78), "HORARIO_86": (9.666666667, 312.78), "HORARIO_85": (12, 312.78),
        "HORARIO_84": (9.5, 312.78), "HORARIO_83": (8.416666667, 312.78), "HORARIO_82": (6, 312.78),
        "HORARIO_81": (10, 312.78), "HORARIO_80": (8.5, 312.78), "HORARIO_8": (11.6, 260.65),
        "HORARIO_79": (14, 312.78), "HORARIO_78": (12, 312.78), "HORARIO_77": (3, 312.78),
        "HORARIO_76": (16, 312.78), "HORARIO_75": (12.16666667, 312.78), "HORARIO_74": (11.33333333, 312.78),
        "HORARIO_73": (12.66666667, 312.78), "HORARIO_72": (11.83333333, 312.78), "HORARIO_71": (11, 312.78),
        "HORARIO_70": (15.16666667, 312.78), "HORARIO_7": (15.33333333, 312.78), "HORARIO_69": (9.166666667, 312.78),
        "HORARIO_68": (4, 312.78), "HORARIO_67": (10, 260.65), "HORARIO_66": (4, 260.65),
        "HORARIO_65": (16.76923077, 338.845), "HORARIO_64": (17.15384615, 338.845), "HORARIO_63": (22.5, 312.78),
        "HORARIO_62": (12.25, 312.78), "HORARIO_61": (4, 312.78), "HORARIO_60": (13, 312.78),
        "HORARIO_6": (18.46153846, 338.845), "HORARIO_59": (12.66666667, 312.78), "HORARIO_58": (12.33333333, 312.78),
        "HORARIO_57": (13.53846154, 338.845), "HORARIO_56": (12.16666667, 312.78), "HORARIO_55": (6.333333333, 312.78),
        "HORARIO_54": (7.230769231, 338.845), "HORARIO_53": (5.5, 312.78), "HORARIO_52": (4, 312.78),
        "HORARIO_51": (14, 338.845), "HORARIO_50": (15, 312.78), "HORARIO_5": (17, 312.78),
        "HORARIO_49": (15.27272727, 286.715), "HORARIO_48": (14.76923077, 338.845), "HORARIO_47": (14.5, 312.78),
        "HORARIO_46": (14.33333333, 312.78), "HORARIO_45": (14.16666667, 312.78), "HORARIO_44": (13.83333333, 312.78),
        "HORARIO_43": (13.5, 312.78), "HORARIO_42": (13.91666667, 312.78), "HORARIO_41": (15, 364.91),
        "HORARIO_40": (15.81818182, 286.715), "HORARIO_4": (16.16666667, 312.78), "HORARIO_39": (15.27272727, 286.715),
        "HORARIO_38": (13.84615385, 338.845), "HORARIO_37": (15.09090909, 286.715), "HORARIO_36": (14, 364.91),
        "HORARIO_35": (14.30769231, 338.845), "HORARIO_34": (14.90909091, 286.715), "HORARIO_33": (13.55, 312.78),
        "HORARIO_32": (14, 338.845), "HORARIO_31": (14.72727273, 286.715), "HORARIO_30": (13.08333333, 312.78),
        "HORARIO_3": (16, 312.78), "HORARIO_29": (14, 286.715), "HORARIO_28": (13, 364.91),
        "HORARIO_27": (14, 286.715), "HORARIO_26": (12.58333333, 312.78), "HORARIO_25": (12, 312.78),
        "HORARIO_24": (13.27272727, 286.715), "HORARIO_23": (11.83333333, 312.78), "HORARIO_22": (11.91666667, 312.78),
        "HORARIO_21": (13.09090909, 286.715), "HORARIO_20": (5, 312.78), "HORARIO_2": (23.5, 364.91),
        "HORARIO_19": (12.18181818, 286.715), "HORARIO_18": (5, 312.78), "HORARIO_17": (9.75, 312.78),
        "HORARIO_16": (10.36363636, 286.715), "HORARIO_15": (10.18181818, 286.715), "HORARIO_14": (8.5, 312.78),
        "HORARIO_134": (12, 364.91), "HORARIO_133": (12, 260.65), "HORARIO_132": (13, 312.78),
        "HORARIO_131": (10, 312.78), "HORARIO_130": (11, 260.65), "HORARIO_13": (9.454545455, 286.715),
        "HORARIO_129": (9.384615385, 338.845), "HORARIO_128": (12.33333333, 312.78), "HORARIO_127": (9.666666667, 312.78),
        "HORARIO_126": (10.83333333, 312.78), "HORARIO_125": (4, 312.78), "HORARIO_124": (13.66666667, 312.78),
        "HORARIO_123": (16.61538462, 338.845), "HORARIO_122": (11, 260.65), "HORARIO_121": (11.66666667, 312.78),
        "HORARIO_120": (8.25, 312.78), "HORARIO_12": (9.272727273, 286.715), "HORARIO_119": (11.23076923, 338.845),
        "HORARIO_118": (11.27272727, 286.715), "HORARIO_117": (11.41666667, 312.78), "HORARIO_116": (11, 312.78),
        "HORARIO_115": (9.25, 312.78), "HORARIO_114": (23.07692308, 338.845), "HORARIO_113": (20, 338.845),
        "HORARIO_112": (10.61538462, 338.845), "HORARIO_111": (9.454545455, 286.715), "HORARIO_110": (6.833333333, 312.78),
        "HORARIO_11": (8, 312.78), "HORARIO_109": (12.90909091, 286.715), "HORARIO_108": (10.54545455, 286.715),
        "HORARIO_107": (12.61538462, 338.845), "HORARIO_106": (14.76923077, 338.845), "HORARIO_105": (12, 156.39),
        "HORARIO_104": (7.666666667, 312.78), "HORARIO_103": (3, 260.65), "HORARIO_102": (10.16666667, 312.78),
        "HORARIO_101": (12, 260.65), "HORARIO_100": (11.16666667, 312.78), "HORARIO_10": (6, 312.78),
        "HORARIO_1": (24, 364.91),
    }
    df['HORARIO'] = df['texto_equipo'].str.strip().str.upper()
    df['HORA/ DIA'] = df['HORARIO'].map(lambda x: horarios_dict.get(x, (None, None))[0])
    df['DIAS/ A√ëO'] = df['HORARIO'].map(lambda x: horarios_dict.get(x, (None, None))[1])
    df['DIAS/ A√ëO'] = pd.to_numeric(df['DIAS/ A√ëO'], errors='coerce')
    df['HORA/ DIA'] = pd.to_numeric(df['HORA/ DIA'], errors='coerce')

    # --- Initial Filtering from first code ---
    df = df.dropna(subset=['EQUIPO'])

    # --- Additional Preprocessing for Second Code's requirements ---
    df["fecha_de_aviso"] = pd.to_datetime(df["fecha_de_aviso"], errors="coerce")
    df["a√±o"] = df["fecha_de_aviso"].dt.year
    df["mes"] = df["fecha_de_aviso"].dt.strftime("%B")

    def extract_description_category(description):
        if pd.isna(description):
            return "Otros"
        match = re.match(r'^([A-Z]{2})/', str(description).strip())
        if match:
            return match.group(1)
        return "Otros"

    df["description_category"] = df['descripcion'].apply(extract_description_category)
    return df

# --- DEFINICI√ìN DE PREGUNTAS PARA EVALUACI√ìN (from first code) ---
preguntas = [
    ("Calidad", "¬øLas soluciones propuestas son coherentes con el diagn√≥stico y causa ra√≠z del problema?", "2,1,0,-1"),
    ("Calidad", "¬øEl trabajo entregado tiene materiales nuevos, originales y de marcas reconocidas?", "2,1,0,-1"),
    ("Calidad", "¬øCuenta con acabados homog√©neos, limpios y pulidos?", "2,1,0,-1"),
    ("Calidad", "¬øEl trabajo entregado corresponde completamente con lo contratado?", "2,1,0,-1"),
    ("Calidad", "¬øLa facturaci√≥n refleja correctamente lo ejecutado y acordado?", "2,1,0,-1"),
    ("Oportunidad", "¬øLa entrega de cotizaciones fue oportuna, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øEl reporte del servicio fue entregado oportunamente, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øCumple las fechas y horas programadas para los trabajos, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øResponde de forma efectiva ante eventualidades emergentes, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øSoluciona r√°pidamente reclamos o inquietudes por garant√≠a, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øDispone de los repuestos requeridos en los tiempos necesarios, seg√∫n el contrato?", "2,1,0,-1"),
    ("Oportunidad", "¬øEntrega las facturas en los tiempos convenidos, seg√∫n el contrato?", "2,1,0,-1"),
    ("Precio", "¬øLos precios ofrecidos para equipos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¬øLos precios ofrecidos para repuestos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¬øLos precios ofrecidos para mantenimientos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Precio", "¬øLos precios ofrecidos para insumos son competitivos respecto al mercado?", "2,1,0,-1"),
    ("Postventa", "¬øTiene disposici√≥n y actitud de servicio frente a solicitudes?", "2,1,0,-1"),
    ("Postventa", "¬øConoce necesidades y ofrece alternativas adecuadas?", "2,1,0,-1"),
    ("Postventa", "¬øRealiza seguimiento a los resultados de los trabajos?", "2,1,0,-1"),
    ("Postventa", "¬øOfrece capacitaciones para el manejo de los equipos?", "2,1,0,-1"),
    ("Postventa", "¬øLos m√©todos de capacitaci√≥n ofrecidos son efectivos y adecuados?", "2,1,0,-1"),
    ("Desempe√±o t√©cnico", "Disponibilidad promedio (%)", "auto"),
    ("Desempe√±o t√©cnico", "MTTR promedio (hrs)", "auto"),
    ("Desempe√±o t√©cnico", "MTBF promedio (hrs)", "auto"),
    ("Desempe√±o t√©cnico", "Rendimiento promedio equipos", "auto"),
]

# --- FUNCIONES DE C√ÅLCULO DE INDICADORES (from first code) ---
def calcular_indicadores_servicio(df_sub):
    if df_sub.empty:
        return pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object)

    cnt = df_sub['TIPO DE SERVICIO'].value_counts()
    cost = df_sub.groupby('TIPO DE SERVICIO')['COSTO'].sum()
    mttr = df_sub.groupby('TIPO DE SERVICIO')['TIEMPO PARADA'].mean()

    ttot = df_sub.groupby('TIPO DE SERVICIO').apply(
        lambda g: (g['DIAS/ A√ëO'].mean() * g['HORA/ DIA'].mean()) if not g['DIAS/ A√ëO'].isnull().all() and not g['HORA/ DIA'].isnull().all() else np.nan
    )

    down = df_sub.groupby('TIPO DE SERVICIO')['TIEMPO PARADA'].sum()
    fails = df_sub.groupby('TIPO DE SERVICIO')['AVISO'].count()
    mtbf = (ttot - down) / fails.replace(0, np.nan)

    disp = (mtbf / (mtbf + mttr)).replace([np.inf, -np.inf], np.nan) * 100
    rend = disp.apply(lambda v: 'Alto' if v >= 90 else ('Medio' if v >= 75 else 'Bajo') if not pd.isna(v) else np.nan)
    return cnt, cost, mttr, mtbf, disp, rend

def calcular_indicadores_equipo(df_sub):
    if df_sub.empty:
        return pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object), pd.Series(dtype=object)

    cnt_equipo = df_sub['EQUIPO'].value_counts()
    cost_equipo = df_sub.groupby('EQUIPO')['COSTO'].sum()
    mttr_equipo = df_sub.groupby('EQUIPO')['TIEMPO PARADA'].mean()

    desc_category_equipo = df_sub.groupby('EQUIPO')['description_category'].first().fillna('Desconocido')

    ttot_equipo = df_sub.groupby('EQUIPO').apply(
        lambda g: (g['DIAS/ A√ëO'].mean() * g['HORA/ DIA'].mean()) if not g['DIAS/ A√ëO'].isnull().all() and not g['HORA/ DIA'].isnull().all() else np.nan
    )

    down_equipo = df_sub.groupby('EQUIPO')['TIEMPO PARADA'].sum()
    fails_equipo = df_sub.groupby('EQUIPO')['AVISO'].count()
    mtbf_equipo = (ttot_equipo - down_equipo) / fails_equipo.replace(0, np.nan)

    disp_equipo = (mtbf_equipo / (mtbf_equipo + mttr_equipo)).replace([np.inf, -np.inf], np.nan) * 100
    rend_equipo = disp_equipo.apply(lambda v: 'Alto' if v >= 90 else ('Medio' if v >= 75 else 'Bajo') if not pd.isna(v) else np.nan)
    return cnt_equipo, cost_equipo, mttr_equipo, mtbf_equipo, disp_equipo, rend_equipo, desc_category_equipo

# --- EVALUATION APP FOR STREAMLIT ---
class EvaluacionProveedoresApp:
    def __init__(self, df):
        self.df = df
        self.all_evaluation_widgets_map = {}
        self.summary_servicio_global_for_export = None
        self.resumen_equipo_global_for_export = None

    def display_evaluation_form(self, df_filtered, prov):
        st.subheader(f"Evaluaci√≥n de Proveedor: {prov}")

        cnt_s, cost_s, mttr_s, mtbf_s, disp_s, rend_s = calcular_indicadores_servicio(df_filtered)
        st.session_state['current_provider_metrics'] = {'cnt': cnt_s, 'cost': cost_s, 'mttr': mttr_s, 'mtbf': mtbf_s, 'disp': disp_s, 'rend': rend_s}

        all_provider_service_types = sorted(df_filtered['TIPO DE SERVICIO'].dropna().unique().tolist())
        st.session_state['all_provider_service_types'] = all_provider_service_types
        st.session_state['all_evaluation_widgets_map'] = st.session_state.get('all_evaluation_widgets_map', {})

        if 'evaluation_page' not in st.session_state:
            st.session_state['evaluation_page'] = 0

        start_index = st.session_state['evaluation_page'] * 5
        end_index = min(start_index + 5, len(all_provider_service_types))
        service_types_on_page = all_provider_service_types[start_index:end_index]

        if not service_types_on_page:
            st.info("No hay tipos de servicio para mostrar en esta p√°gina.")
            return

        st.markdown("### Calificaci√≥n de Preguntas por Tipo de Servicio")
        st.info("Utiliza los selectores para asignar una puntuaci√≥n a cada pregunta por tipo de servicio.")

        # Display service type mapping for the current page
        with st.expander("Ver mapeo de Tipos de Servicio en esta p√°gina"):
            if service_types_on_page:
                for st_val in service_types_on_page:
                    idx = all_provider_service_types.index(st_val) + 1
                    st.write(f"Servicio {idx}: {st_val}")
            else:
                st.write("No hay tipos de servicio en esta p√°gina para mapear.")

        col_questions, *col_services = st.columns([0.4] + [0.15] * len(service_types_on_page))

        with col_questions:
            st.write("**Pregunta**")
        for i, st_label in enumerate(service_types_on_page):
            with col_services[i]:
                global_idx = all_provider_service_types.index(st_label) + 1
                st.write(f"**Servicio {global_idx} ({st_label})**")

        for cat, texto, escala in preguntas:
            with col_questions:
                st.markdown(f"**[{cat}]** {texto}")

            for i, st_original in enumerate(service_types_on_page):
                with col_services[i]:
                    unique_key = f"{cat}-{texto}-{st_original}"
                    if escala == "auto":
                        val = 0
                        metrics = st.session_state['current_provider_metrics']
                        disp = metrics.get('disp', pd.Series())
                        mttr = metrics.get('mttr', pd.Series())
                        mtbf = metrics.get('mtbf', pd.Series())
                        rend = metrics.get('rend', pd.Series())

                        if 'Disponibilidad' in texto and st_original in disp and not pd.isna(disp[st_original]):
                            mean_disp = disp[st_original]
                            val = 2 if mean_disp >= 98 else (1 if mean_disp >= 75 else 0)
                        elif 'MTTR' in texto and st_original in mttr and not pd.isna(mttr[st_original]):
                            mean_mttr = mttr[st_original]
                            val = 2 if mean_mttr <= 5 else (1 if mean_mttr <= 20 else 0)
                        elif 'MTBF' in texto and st_original in mtbf and not pd.isna(mtbf[st_original]):
                            mean_mtbf = mtbf[st_original]
                            val = 2 if mean_mtbf > 1000 else (1 if mean_mtbf >= 100 else 0)
                        elif 'Rendimiento' in texto and st_original in rend and not pd.isna(rend[st_original]):
                            perf_class = rend[st_original]
                            if perf_class == 'Alto':
                                val = 2
                            elif perf_class == 'Medio':
                                val = 1
                            elif perf_class == 'Bajo':
                                val = 0
                        st.write(str(val))
                        st.session_state['all_evaluation_widgets_map'][unique_key] = val # Store fixed value
                    else:
                        opts = {'Sobresaliente (2)': 2, 'Bueno (1)': 1, 'Indiferente (0)': 0, 'Malo (-1)': -1}
                        current_value = st.session_state['all_evaluation_widgets_map'].get(unique_key, 0)
                        selected_option = st.selectbox(
                            label=" ",
                            options=list(opts.keys()),
                            format_func=lambda x: x.split(' ')[0], # Display only the rating word
                            key=unique_key,
                            index=list(opts.values()).index(current_value) if current_value in list(opts.values()) else 2 # Default to Indiferente (0)
                        )
                        st.session_state['all_evaluation_widgets_map'][unique_key] = opts[selected_option]

        col1, col2 = st.columns([1,1])
        with col1:
            if st.button("Anterior", key="prev_eval_page", disabled=(st.session_state['evaluation_page'] == 0)):
                st.session_state['evaluation_page'] -= 1
                st.experimental_rerun()
        with col2:
            if st.button("Siguiente", key="next_eval_page", disabled=(end_index >= len(all_provider_service_types))):
                st.session_state['evaluation_page'] += 1
                st.experimental_rerun()

        st.markdown("---")
        if st.button("Generar Resumen de Evaluaci√≥n y Exportar a Excel"):
            self.generar_resumen_evaluacion(df_filtered)

        # Plotting if metrics are available
        metrics = st.session_state.get('current_provider_metrics', {})
        rend_data = metrics.get('rend', pd.Series())
        mttr_data = metrics.get('mttr', pd.Series())
        mtbf_data = metrics.get('mtbf', pd.Series())
        disp_data = metrics.get('disp', pd.Series())

        if not rend_data.empty:
            self.graficar_rendimiento(rend_data)
        else:
            st.info("No hay datos de rendimiento para graficar.")

        if not mttr_data.empty or not mtbf_data.empty or not disp_data.empty:
            self.graficar_resumen(mttr_data, mtbf_data, disp_data)
        else:
            st.info("No hay datos de MTTR, MTBF o Disponibilidad para graficar.")

    def generar_resumen_evaluacion(self, df_filtered):
        st.subheader("Generando resumen de evaluaci√≥n...")

        if not st.session_state.get('all_evaluation_widgets_map'):
            st.warning("No hay evaluaciones para resumir. Selecciona un proveedor y completa las evaluaciones.")
            return

        all_provider_service_types = st.session_state.get('all_provider_service_types', [])
        unique_service_types = sorted(list(set([key.split('-')[2] for key in st.session_state['all_evaluation_widgets_map'].keys()])))

        all_categories = sorted(list(set([p[0] for p in preguntas])))
        category_service_scores = {cat: {st_val: 0 for st_val in unique_service_types} for cat in all_categories}
        service_type_totals = {st_val: 0 for st_val in unique_service_types}

        for unique_key, score in st.session_state['all_evaluation_widgets_map'].items():
            try:
                cat, q_text, st_original = unique_key.split('-', 2)
                category_service_scores[cat][st_original] += score
                service_type_totals[st_original] += score
            except ValueError:
                st.warning(f"Advertencia: No se pudo obtener la puntuaci√≥n para el key '{unique_key}'. Aseg√∫rate de que el valor sea num√©rico.")
            except KeyError:
                st.warning(f"Advertencia: Categor√≠a '{cat}' o tipo de servicio '{st_original}' no encontrado en la estructura de puntuaci√≥n.")

        summary_df_calificacion = pd.DataFrame.from_dict(category_service_scores, orient='index')
        summary_df_calificacion.index.name = 'Categor√≠a'
        summary_df_calificacion.loc['Total por Calificaci√≥n de Servicio'] = pd.Series(service_type_totals)

        service_type_display_names_cal = {st_val: f"Servicio {all_provider_service_types.index(st_val) + 1} ({st_val})"
                                          for st_val in unique_service_types if st_val in all_provider_service_types}
        for st_val in unique_service_types:
            if st_val not in all_provider_service_types:
                service_type_display_names_cal[st_val] = f"Servicio Nuevo ({st_val})"

        summary_df_calificacion = summary_df_calificacion.rename(columns=service_type_display_names_cal)
        summary_df_calificacion.columns.name = 'Tipo de Servicio'

        prov_name = st.session_state['selected_provider'].replace(" ", "_").replace("/", "-")
        output_filename = f"resumen_evaluacion_{prov_name}.xlsx"

        # Prepare metrics for export
        metrics = st.session_state.get('current_provider_metrics', {})
        cnt_s = metrics.get('cnt', pd.Series())
        cost_s = metrics.get('cost', pd.Series())
        mttr_s = metrics.get('mttr', pd.Series())
        mtbf_s = metrics.get('mtbf', pd.Series())
        disp_s = metrics.get('disp', pd.Series())
        rend_s = metrics.get('rend', pd.Series())

        summary_servicio_export = pd.DataFrame({
            'Cantidad de Avisos': cnt_s,
            'Costo Total': cost_s,
            'Disponibilidad (%)': disp_s.round(2) if not disp_s.empty else np.nan,
            'MTTR (hrs)': mttr_s.round(2) if not mttr_s.empty else np.nan,
            'MTBF (hrs)': mtbf_s.round(2) if not mtbf_s.empty else np.nan,
            'Rendimiento': rend_s
        }).reset_index().rename(columns={'index': 'TIPO DE SERVICIO'}).sort_values('Disponibilidad (%)', ascending=False)
        for col in ['Disponibilidad (%)', 'MTTR (hrs)', 'MTBF (hrs)']:
            if col in summary_servicio_export.columns:
                summary_servicio_export[col] = summary_servicio_export[col].fillna(0)

        cnt_e, cost_e, mttr_e, mtbf_e, disp_e, rend_e, desc_category_e = calcular_indicadores_equipo(df_filtered)
        resumen_equipo_export = pd.DataFrame({
            'Avisos': cnt_e,
            'Costo total': cost_e,
            'MTTR': mttr_e.round(2) if not mttr_e.empty else np.nan,
            'MTBF': mtbf_e.round(2) if not mtbf_e.empty else np.nan,
            'Disponibilidad (%)': disp_e.round(2) if not disp_e.empty else np.nan,
            'Rendimiento': rend_e,
            'Categor√≠a de Descripci√≥n': desc_category_e
        }).reset_index().rename(columns={'index': 'Denominacion'})
        for col in ['Disponibilidad (%)', 'MTTR', 'MTBF']:
            if col in resumen_equipo_export.columns:
                resumen_equipo_export[col] = resumen_equipo_export[col].fillna(0)

        # Create an in-memory Excel file
        excel_buffer = io.BytesIO()
        with pd.ExcelWriter(excel_buffer, engine='xlsxwriter') as writer:
            if not summary_servicio_export.empty:
                summary_servicio_export.to_excel(writer, sheet_name='Resumen_Servicio', index=False)
            else:
                st.warning("No se encontr√≥ la tabla de resumen por Tipo de Servicio para exportar o est√° vac√≠a.")

            if not resumen_equipo_export.empty:
                resumen_equipo_export.to_excel(writer, sheet_name='Resumen_Equipo', index=False)
            else:
                st.warning("No se encontr√≥ la tabla de resumen por Equipo para exportar o est√° vac√≠a.")

            if not summary_df_calificacion.empty:
                summary_df_calificacion.to_excel(writer, sheet_name='Resumen_Calificacion')
            else:
                 st.warning("No se encontr√≥ la tabla de resumen de Calificaci√≥n para exportar o est√° vac√≠a.")

        excel_buffer.seek(0) # Rewind the buffer before sending it
        st.download_button(
            label="Descargar Resumen de Evaluaci√≥n (Excel)",
            data=excel_buffer,
            file_name=output_filename,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help="Descarga el resumen de evaluaci√≥n en formato XLSX."
        )
        st.success(f"Resumen de evaluaci√≥n generado y listo para descargar.")


    def graficar_rendimiento(self, rend):
        if rend.empty:
            st.info("No hay datos de rendimiento para graficar.")
            return

        rend_filtered = rend.dropna()
        if rend_filtered.empty:
            st.info("No hay datos de rendimiento v√°lidos para graficar despu√©s de eliminar NaNs.")
            return

        rend_counts = rend_filtered.value_counts().reindex(['Alto', 'Medio', 'Bajo'], fill_value=0)

        if rend_counts.sum() > 0:
            colores = ['#66bb6a', '#ffee58', '#ef5350']
            active_colors = [color for i, color in enumerate(colores) if rend_counts.iloc[i] > 0]
            labels = [f'{idx} ({val}%)' for idx, val in rend_counts.items() if val > 0]
            sizes = [val for val in rend_counts.values if val > 0]

            if not sizes:
                st.info("No hay datos de rendimiento para mostrar en el gr√°fico de pastel.")
                return

            fig_pie, ax_pie = plt.subplots(figsize=(6, 6))
            wedges, texts, autotexts = ax_pie.pie(sizes, autopct='%1.1f%%', colors=active_colors, startangle=90, counterclock=False, pctdistance=0.85)
            ax_pie.set_title('Distribuci√≥n Rendimiento por Tipo de Servicio')
            ax_pie.set_ylabel('')
            ax_pie.axis('equal')
            st.pyplot(fig_pie)
        else:
            st.info("No hay datos v√°lidos de rendimiento para graficar.")

    def graficar_resumen(self, mttr, mtbf, disp):
        plots_to_make = 0
        if not mttr.dropna().empty: plots_to_make += 1
        if not mtbf.dropna().empty: plots_to_make += 1
        if not disp.dropna().empty: plots_to_make += 1

        if plots_to_make == 0:
            st.info("No hay datos de MTTR, MTBF o Disponibilidad para graficar.")
            return

        fig_hist, axs = plt.subplots(1, plots_to_make, figsize=(5 * plots_to_make, 4))
        if plots_to_make == 1:
            axs = [axs]

        plot_idx = 0
        if not mttr.dropna().empty:
            sns.histplot(mttr.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='skyblue')
            axs[plot_idx].set_title('MTTR Promedio por Servicio (hrs)')
            plot_idx += 1
        if not mtbf.dropna().empty:
            sns.histplot(mtbf.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='lightgreen')
            axs[plot_idx].set_title('MTBF Promedio por Servicio (hrs)')
            plot_idx += 1
        if not disp.dropna().empty:
            sns.histplot(disp.dropna(), bins=10, kde=True, ax=axs[plot_idx], color='salmon')
            axs[plot_idx].set_title('Disponibilidad Promedio por Servicio (%)')
            plot_idx += 1

        plt.tight_layout()
        st.pyplot(fig_hist)


# --- COST AND NOTICE ANALYSIS APP FOR STREAMLIT ---
class CostosAvisosApp:
    def __init__(self, df):
        self.df = df
        self.EJECUTANTE_COL_NAME_NORMALIZED = "denominacion_ejecutante"
        self.COL_COSTOS_NORMALIZED = "costes_totreales"
        self.CP_COL_NAME_NORMALIZED = "codigo_postal"
        self.DESCRIPTION_COL_NAME_NORMALIZED = "descripcion"

        # Ensure filters use only valid options from the DataFrame
        self.ejecutantes = sorted(self.df[self.EJECUTANTE_COL_NAME_NORMALIZED].dropna().unique().tolist())
        self.cps = sorted(self.df[self.CP_COL_NAME_NORMALIZED].dropna().unique().tolist())
        self.a√±os = sorted(self.df["a√±o"].dropna().unique().tolist())
        self.meses = sorted(self.df["mes"].dropna().unique().tolist(), key=lambda x: pd.to_datetime(x, format="%B").month)

        self.opciones_menu = {
            "Costos por ejecutante": (self.EJECUTANTE_COL_NAME_NORMALIZED, self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por ejecutante": (self.EJECUTANTE_COL_NAME_NORMALIZED, None, "avisos"),
            "Costos por objeto t√©cnico": ("denominacion_de_objeto_tecnico", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por objeto t√©cnico": ("denominacion_de_objeto_tecnico", None, "avisos"),
            "Costos por texto c√≥digo acci√≥n": ("texto_codigo_accion", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por texto c√≥digo acci√≥n": ("texto_codigo_accion", None, "avisos"),
            "Costos por texto de acci√≥n": ("texto_de_accion", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por texto de acci√≥n": ("texto_de_accion", None, "avisos"),
            "Costos por tipo de servicio": ("tipo_de_servicio", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por tipo de servicio": ("tipo_de_servicio", None, "avisos"),
            "Costos por categor√≠a de descripci√≥n": ("description_category", self.COL_COSTOS_NORMALIZED, "costos"),
            "Avisos por categor√≠a de descripci√≥n": ("description_category", None, "avisos"),
        }

        if 'costos_page' not in st.session_state:
            st.session_state['costos_page'] = 0
        if 'current_grouped_data' not in st.session_state:
            st.session_state['current_grouped_data'] = pd.Series()
        if 'selected_costos_option' not in st.session_state:
            st.session_state['selected_costos_option'] = list(self.opciones_menu.keys())[0]

    def formato_coste(self, valor):
        if pd.isna(valor):
            return "$ N/A"
        return f"$ {valor:,.0f}COP".replace(",", ".")

    def custom_cost_formatter(self, x, pos):
        if x >= 1e9:
            return f"${x*1e-9:.0f}B"
        elif x >= 1e6:
            return f"${x*1e-6:.0f}M"
        elif x >= 1e3:
            return f"${x*1e-3:.0f}K"
        else:
            return f"${x:.0f}"

    def plot_points_with_labels(self, data, title, xlabel="", ylabel="", color="skyblue", rotation=45):
        if data.empty:
            st.info(f"No hay datos para graficar: {title}")
            return

        fig, ax = plt.subplots(figsize=(12, 6))
        x_labels = data.index.astype(str)
        x_positions = np.arange(len(data))

        ax.scatter(x_positions, data.values, color=color, zorder=2)

        for i, txt in enumerate(data.values):
            if "avisos" in title.lower():
                label_text = f"{int(txt):,}".replace(",", ".")
            else:
                label_text = self.custom_cost_formatter(txt, None)
            ax.text(x_positions[i], txt, label_text, ha='center', va='bottom', fontsize=9, color='black')

        ax.set_title(title)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.set_xticks(x_positions)
        ax.set_xticklabels(x_labels, rotation=rotation, ha="right")

        if "costos" in title.lower():
            ax.yaxis.set_major_formatter(plt.FuncFormatter(self.custom_cost_formatter))

        ax.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        st.pyplot(fig)


    def display_costos_avisos_app(self):
        st.subheader("An√°lisis de Costos y Avisos")

        col1, col2 = st.columns(2)
        with col1:
            selected_ejecutantes = st.multiselect("Ejecutante", options=self.ejecutantes, default=self.ejecutantes)
        with col2:
            selected_cps = st.multiselect("C√≥digo postal", options=self.cps, default=self.cps)

        col3, col4 = st.columns(2)
        with col3:
            selected_a√±o = st.selectbox("A√±o", options=["Todos"] + self.a√±os, index=0)
        with col4:
            selected_mes = st.selectbox("Mes", options=["Todos"] + self.meses, index=0)

        selected_option = st.selectbox(
            "Ver:",
            options=list(self.opciones_menu.keys()),
            key="costos_menu_select",
            on_change=self._reset_costos_page,
            args=(selected_ejecutantes, selected_cps, selected_a√±o, selected_mes) # Pass current filters to on_change
        )
        st.session_state['selected_costos_option'] = selected_option

        # Filter data based on selections
        df_filtered = self.df.copy()
        if selected_ejecutantes:
            df_filtered = df_filtered[df_filtered[self.EJECUTANTE_COL_NAME_NORMALIZED].isin(selected_ejecutantes)]
        if selected_cps:
            df_filtered = df_filtered[df_filtered[self.CP_COL_NAME_NORMALIZED].isin(selected_cps)]
        if selected_a√±o != "Todos":
            df_filtered = df_filtered[df_filtered["a√±o"] == selected_a√±o]
        if selected_mes != "Todos":
            df_filtered = df_filtered[df_filtered["mes"] == selected_mes]

        if df_filtered.empty:
            st.info("No hay datos que coincidan con los filtros seleccionados.")
            st.session_state['current_grouped_data'] = pd.Series()
            return

        col, col_cost, tipo = self.opciones_menu[selected_option]

        if col not in df_filtered.columns:
            st.error(f"Error: La columna '{col}' no se encontr√≥ en los datos filtrados. Columnas disponibles: {df_filtered.columns.tolist()}")
            st.session_state['current_grouped_data'] = pd.Series()
            return

        if tipo == "costos":
            if col_cost not in df_filtered.columns:
                st.error(f"Error: La columna de costos '{col_cost}' no se encontr√≥ en los datos filtrados.")
                st.session_state['current_grouped_data'] = pd.Series()
                return
            grouped_data = df_filtered.groupby(col)[col_cost].sum().sort_values(ascending=False)
        else:
            grouped_data = df_filtered[col].value_counts().sort_values(ascending=False)

        st.session_state['current_grouped_data'] = grouped_data

        if grouped_data.empty:
            st.info(f"No hay datos para mostrar para la opci√≥n '{selected_option}' con los filtros actuales.")
            return

        # Pagination logic
        items_per_page = 20
        total_items = len(grouped_data)
        max_page = max(0, (total_items - 1) // items_per_page)

        st.session_state['costos_page'] = min(st.session_state['costos_page'], max_page) # Adjust page if filters change data size

        start_idx = st.session_state['costos_page'] * items_per_page
        end_idx = min(start_idx + items_per_page, total_items)
        data_to_display = grouped_data.iloc[start_idx:end_idx]

        st.markdown(f"### Resultados ({selected_option}) - P√°gina {st.session_state['costos_page'] + 1} de {max_page + 1}")

        # Display table
        if tipo == "costos":
            df_table = data_to_display.apply(self.formato_coste).to_frame().reset_index()
            df_table.columns = [col.replace("_", " ").title() for col in df_table.columns] # Prettify column names
        else:
            df_table = data_to_display.to_frame().reset_index()
            df_table.columns = [col.replace("_", " ").title() for col in df_table.columns] # Prettify column names
        st.dataframe(df_table, use_container_width=True)

        # Pagination buttons
        col_prev, col_next = st.columns([1,1])
        with col_prev:
            if st.button("‚Üê P√°gina anterior", key="costos_prev_page", disabled=(st.session_state['costos_page'] == 0)):
                st.session_state['costos_page'] -= 1
                st.experimental_rerun()
        with col_next:
            if st.button("P√°gina siguiente ‚Üí", key="costos_next_page", disabled=(st.session_state['costos_page'] >= max_page)):
                st.session_state['costos_page'] += 1
                st.experimental_rerun()

        # Display plot
        self.plot_points_with_labels(data_to_display,
                                     f"{selected_option} - P√°gina {st.session_state['costos_page'] + 1} de {max_page + 1}",
                                     xlabel=col.replace("_", " ").title(),
                                     ylabel="Costo Total (COP)" if tipo == "costos" else "N√∫mero de Avisos")

    def _reset_costos_page(self, *args):
        st.session_state['costos_page'] = 0


# --- Main Application Logic ---
st.title("¬°Hola, usuario Sura! üëã")
st.markdown("---")
st.header("Proyecto de **Gerencia de Gesti√≥n Administrativa** en Ingenier√≠a Cl√≠nica")
st.markdown("""
    Aqu√≠ podr√°s **analizar y gestionar los datos de avisos** para optimizar los procesos.
    Por favor, **sube el archivo `DATA2.XLSX`** para comenzar.
""")

uploaded_file = st.file_uploader("Sube tu archivo 'DATA2.XLSX' aqu√≠", type=["xlsx"])

if uploaded_file:
    file_buffer = io.BytesIO(uploaded_file.getvalue())

    with st.spinner('Cargando y procesando datos... Esto puede tomar un momento.'):
        try:
            df = load_and_merge_data(file_buffer)

            # Eliminar registros cuyo 'Status del sistema' contenga "PTBO"
            initial_rows = len(df)
            df = df[~df["status_del_sistema"].str.contains("PTBO", case=False, na=False)]
            st.info(f"Se eliminaron {initial_rows - len(df)} registros con 'PTBO' en 'Status del sistema'.")

            # Dejar solo una fila con coste por cada aviso
            df['costes_totreales'] = df.groupby('aviso')['costes_totreales'].transform(
                lambda x: [x.iloc[0]] + [0]*(len(x)-1)
            )
            df['COSTO'] = df['costes_totreales'] # Update the 'COSTO' column as well

            st.success("‚úÖ Datos cargados y procesados exitosamente.")
            st.write(f"**Filas finales:** {len(df)} ‚Äì **Columnas:** {len(df.columns)}")

            st.markdown("---")
            st.subheader("Vista previa de los datos procesados:")
            st.dataframe(df.head(10))

            st.markdown("---")
            st.subheader("Descarga de Datos Procesados")

            csv_output = df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="Descargar como CSV",
                data=csv_output,
                file_name="avisos_filtrados.csv",
                mime="text/csv",
                help="Descarga el archivo en formato CSV."
            )

            excel_buffer_download = io.BytesIO()
            df.to_excel(excel_buffer_download, index=False, engine='openpyxl')
            excel_buffer_download.seek(0)
            st.download_button(
                label="Descargar como Excel",
                data=excel_buffer_download,
                file_name="avisos_filtrados.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                help="Descarga el archivo en formato XLSX."
            )

            st.markdown("---")
            st.success("¬°El procesamiento ha finalizado! Ahora puedes descargar tus datos o seguir explorando.")

            # Initialize session state for app navigation
            if 'app_mode' not in st.session_state:
                st.session_state['app_mode'] = 'main_menu'

            evaluacion_app = EvaluacionProveedoresApp(df)
            costos_avisos_app = CostosAvisosApp(df)

            # Main menu in sidebar
            with st.sidebar:
                st.header("Men√∫ Principal")
                if st.button("Evaluaci√≥n de Proveedores", key="menu_evaluacion"):
                    st.session_state['app_mode'] = 'evaluacion'
                    st.session_state['evaluation_page'] = 0 # Reset evaluation page on menu click
                    st.session_state['all_evaluation_widgets_map'] = {} # Reset evaluations
                    st.session_state['current_provider_metrics'] = {}
                if st.button("An√°lisis de Costos y Avisos", key="menu_costos"):
                    st.session_state['app_mode'] = 'costos_avisos'
                    st.session_state['costos_page'] = 0 # Reset costos page on menu click

            if st.session_state['app_mode'] == 'main_menu':
                st.info("Selecciona una opci√≥n del men√∫ lateral para comenzar.")
            elif st.session_state['app_mode'] == 'evaluacion':
                st.sidebar.markdown("---")
                st.sidebar.button("Volver al Men√∫ Principal", key="back_to_main_eval", on_click=lambda: st.session_state.update({'app_mode': 'main_menu', 'evaluation_page': 0}))

                st.header("Evaluaci√≥n de Proveedores")
                providers = ["Todos"] + sorted(df['PROVEEDOR'].dropna().unique().tolist())
                selected_provider = st.selectbox("Selecciona un Proveedor", providers, key="provider_select")
                st.session_state['selected_provider'] = selected_provider

                if selected_provider == "Todos":
                    df_to_evaluate = df.copy()
                else:
                    df_to_evaluate = df[df['PROVEEDOR'] == selected_provider].copy()

                if df_to_evaluate.empty:
                    st.warning(f"No hay datos disponibles para el proveedor '{selected_provider}'.")
                    st.session_state['all_evaluation_widgets_map'] = {}
                else:
                    evaluacion_app.display_evaluation_form(df_to_evaluate, selected_provider)

            elif st.session_state['app_mode'] == 'costos_avisos':
                st.sidebar.markdown("---")
                st.sidebar.button("Volver al Men√∫ Principal", key="back_to_main_costos", on_click=lambda: st.session_state.update({'app_mode': 'main_menu', 'costos_page': 0}))
                costos_avisos_app.display_costos_avisos_app()


        except Exception as e:
            st.error(f"‚ùå ¬°Ups! Ocurri√≥ un error al procesar el archivo: {e}")
            st.warning("Por favor, verifica que el archivo subido sea `DATA2.XLSX` y tenga el formato de hojas esperado.")
            st.exception(e)
else:
    st.info("‚¨ÜÔ∏è Sube tu archivo `DATA2.XLSX` para empezar con el an√°lisis.")
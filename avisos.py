# -*- coding: utf-8 -*-
"""avisos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0ucN4kG4Y3v2ym3Sdye9h_33n32RKUH
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re
import io # Importamos io para manejar archivos en memoria

# --- Configuraci√≥n de la p√°gina (tem√°tica Sura) ---
st.set_page_config(
    page_title="Gerencia de Gesti√≥n Administrativa - Sura",
    layout="wide",
    initial_sidebar_state="expanded",
    # Icono de la p√°gina (opcional, puedes cambiar 'üìà' por el tuyo)
    # Abre este enlace para ver m√°s emojis: https://www.webfx.com/tools/emoji-cheat-sheet/
)

# Estilos CSS para ambientar en amarillo, blanco y azul rey
st.markdown(
    """
    <style>
    /* Estilos generales del fondo con degradado */
    .stApp {
        background: linear-gradient(to right, #FFFFFF, #FFFACD, #4169E1); /* Blanco, Amarillo claro (Cream), Azul Rey */
        color: #333333; /* Color de texto general */
    }
    /* Sidebar */
    .st-emotion-cache-1oe6z58 { /* Esta clase puede cambiar en futuras versiones de Streamlit */
        background-color: #F0F8FF; /* Azul claro para la sidebar */
    }
    /* T√≠tulos */
    h1, h2, h3, h4, h5, h6 {
        color: #4169E1; /* Azul Rey para los t√≠tulos */
    }
    /* Botones */
    .stButton>button {
        background-color: #4169E1; /* Azul Rey para los botones */
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.3s ease;
    }
    .stButton>button:hover {
        background-color: #F8D568; /* Amarillo para hover */
        color: #4169E1;
        border: 1px solid #4169E1;
    }
    /* Contenedores de contenido principal */
    .st-emotion-cache-z5fcl4, .st-emotion-cache-1c7y2kl, .st-emotion-cache-nahz7x { /* Clases gen√©ricas para contenedores */
        background-color: rgba(255, 255, 255, 0.9); /* Blanco semitransparente */
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
    }
    /* Mejoras para la tabla (dataframe) */
    .streamlit-dataframe {
        border-radius: 0.5rem;
        overflow: hidden; /* Asegura que las esquinas redondeadas se apliquen bien */
    }
    </style>
    """,
    unsafe_allow_html=True
)

# --- Bienvenida y encabezado ---
st.title("¬°Hola, usuario Sura! üëã")
st.markdown("---")
st.header("Proyecto de **Gerencia de Gesti√≥n Administrativa** en Ingenier√≠a Cl√≠nica")
st.markdown("""
    Aqu√≠ podr√°s **analizar y gestionar los datos de avisos** para optimizar los procesos.
    Por favor, **sube el archivo `DATA2.XLSX`** para comenzar.
""")

# --- Funci√≥n de carga & uni√≥n (optimizada para Streamlit) ---
@st.cache_data
def load_and_merge_data(uploaded_file_buffer: io.BytesIO) -> pd.DataFrame:
    """
    Carga y fusiona los datos de las diferentes hojas de un archivo Excel.

    Args:
        uploaded_file_buffer (io.BytesIO): Buffer del archivo Excel subido por el usuario.

    Returns:
        pd.DataFrame: El DataFrame combinado y limpio.
    """
    # Cargar hojas directamente desde el buffer
    iw29 = pd.read_excel(uploaded_file_buffer, sheet_name=0)
    uploaded_file_buffer.seek(0) # Rebobinar el buffer para leer la siguiente hoja
    iw39 = pd.read_excel(uploaded_file_buffer, sheet_name=1)
    uploaded_file_buffer.seek(0)
    ih08 = pd.read_excel(uploaded_file_buffer, sheet_name=2)
    uploaded_file_buffer.seek(0)
    iw65 = pd.read_excel(uploaded_file_buffer, sheet_name=3)
    uploaded_file_buffer.seek(0)
    zpm015 = pd.read_excel(uploaded_file_buffer, sheet_name=4)

    # Limpiar encabezados
    for df_temp in (iw29, iw39, ih08, iw65, zpm015):
        df_temp.columns = df_temp.columns.str.strip()

    # Guardar "Equipo" original desde IW29 para evitar p√©rdida
    equipo_original = iw29[["Aviso", "Equipo", "Duraci√≥n de parada", "Descripci√≥n"]].copy()

    # Extraer solo columnas necesarias de iw39 para el merge (incluyendo 'Total general (real)')
    iw39_subset = iw39[["Aviso", "Total general (real)"]]

    # Unir por 'Aviso'
    tmp1 = pd.merge(iw29, iw39_subset, on="Aviso", how="left")
    tmp2 = pd.merge(tmp1, iw65, on="Aviso", how="left")

    # Restaurar el valor original de "Equipo" de IW29 despu√©s del merge
    tmp2.drop(columns=["Equipo"], errors='ignore', inplace=True)
    tmp2 = pd.merge(tmp2, equipo_original, on="Aviso", how="left")

    # Unir por 'Equipo' con IH08
    tmp3 = pd.merge(tmp2, ih08[[
        "Equipo", "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto", "Indicador ABC", "Denominaci√≥n de objeto t√©cnico"
    ]], on="Equipo", how="left")

    # Unir por 'Equipo' con ZPM015
    tmp4 = pd.merge(tmp3, zpm015[["Equipo", "TIPO DE SERVICIO"]], on="Equipo", how="left")

    # Renombrar columnas
    tmp4.rename(columns={
        "Texto": "Texto_equipo",
        "Total general (real)": "Costes tot.reales"
    }, inplace=True)

    columnas_finales = [
        "Aviso", "Orden", "Fecha de aviso", "C√≥digo postal", "Status del sistema",
        "Descripci√≥n", "Ubicaci√≥n t√©cnica", "Indicador", "Equipo",
        "Denominaci√≥n de objeto t√©cnico", "Denominaci√≥n ejecutante",
        "Duraci√≥n de parada", "Centro de coste", "Costes tot.reales",
        "Inic.garant√≠a prov.", "Fin garant√≠a prov.", "Texto_equipo",
        "Indicador ABC", "Texto c√≥digo acci√≥n", "Texto de acci√≥n",
        "Texto grupo acci√≥n", "TIPO DE SERVICIO"
    ]

    # Filtrar solo las columnas que realmente existen en tmp4
    columnas_finales = [col for col in columnas_finales if col in tmp4.columns]

    return tmp4[columnas_finales]

# --- 3. Uploader y Ejecuci√≥n ---
uploaded_file = st.file_uploader("Sube tu archivo 'DATA2.XLSX' aqu√≠", type=["xlsx"])

if uploaded_file:
    # Usamos io.BytesIO para pasar el archivo como un buffer en memoria
    # Esto es crucial para que read_excel pueda leer m√∫ltiples hojas del mismo archivo
    # sin tener que guardarlo en el disco del servidor de Streamlit.
    file_buffer = io.BytesIO(uploaded_file.getvalue())

    with st.spinner('Cargando y procesando datos... Esto puede tomar un momento.'):
        try:
            df = load_and_merge_data(file_buffer)

            # --- Procesamiento adicional ---
            # Eliminar registros cuyo 'Status del sistema' contenga "PTBO"
            initial_rows = len(df)
            df = df[~df["Status del sistema"].str.contains("PTBO", case=False, na=False)]
            st.info(f"Se eliminaron {initial_rows - len(df)} registros con 'PTBO' en 'Status del sistema'.")

            # Dejar solo una fila con coste por cada aviso
            df['Costes tot.reales'] = df.groupby('Aviso')['Costes tot.reales'].transform(
                lambda x: [x.iloc[0]] + [0]*(len(x)-1)
            )

            st.success("‚úÖ Datos cargados y procesados exitosamente.")
            st.write(f"**Filas finales:** {len(df)} ‚Äì **Columnas:** {len(df.columns)}")

            # --- Visualizaci√≥n y Descarga ---
            st.markdown("---")
            st.subheader("Vista previa de los datos procesados:")
            st.dataframe(df.head(10)) # Mostrar m√°s filas para una mejor vista previa

            st.markdown("---")
            st.subheader("Descarga de Datos Procesados")

            # Preparar CSV para descarga
            csv_output = df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="Descargar como CSV",
                data=csv_output,
                file_name="avisos_filtrados.csv",
                mime="text/csv",
                help="Descarga el archivo en formato CSV."
            )

            # Preparar Excel para descarga
            excel_buffer = io.BytesIO()
            df.to_excel(excel_buffer, index=False, engine='openpyxl')
            excel_buffer.seek(0) # Rebobinar el buffer antes de enviarlo
            st.download_button(
                label="Descargar como Excel",
                data=excel_buffer,
                file_name="avisos_filtrados.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                help="Descarga el archivo en formato XLSX."
            )

            st.markdown("---")
            st.success("¬°El procesamiento ha finalizado! Ahora puedes descargar tus datos o seguir explorando.")

        except Exception as e:
            st.error(f"‚ùå ¬°Ups! Ocurri√≥ un error al procesar el archivo: {e}")
            st.warning("Por favor, verifica que el archivo subido sea `DATA2.XLSX` y tenga el formato de hojas esperado.")
            st.exception(e) # Muestra el traceback completo para depuraci√≥n
else:
    st.info("‚¨ÜÔ∏è Sube tu archivo `DATA2.XLSX` para empezar con el an√°lisis.")


# Set a nice style for plots
sns.set_style('whitegrid')

# --- Data Loading and Preprocessing ---
@st.cache_data
def load_data(uploaded_file):
    if uploaded_file is not None:
        try:
            df = pd.read_excel(uploaded_file)
            return df
        except Exception as e:
            st.error(f"Error al cargar el archivo: {e}")
            return pd.DataFrame()
    return pd.DataFrame()

def preprocess_data(df):
    if df.empty:
        return df

    # Convert 'Fecha de Registro' to datetime and extract year
    df['Fecha de Registro'] = pd.to_datetime(df['Fecha de Registro'], errors='coerce')
    df = df.dropna(subset=['Fecha de Registro'])
    df['A√±o'] = df['Fecha de Registro'].dt.year

    # Clean 'Costo Total'
    df['Costo Total'] = df['Costo Total'].replace({'\$': '', ',': ''}, regex=True).astype(float)

    # Clean 'Descripci√≥n' for categorization
    def categorize_description(description):
        description = str(description).lower()
        if re.search(r'publicaci√≥n|aviso|prensa|peri√≥dico|comunicado', description):
            return 'Publicaci√≥n/Aviso'
        elif re.search(r'valla|pasacalle|pend√≥n', description):
            return 'Valla/Pasacalle/Pend√≥n'
        elif re.search(r'radio|emisora', description):
            return 'Radio'
        elif re.search(r'televisi√≥n|tv', description):
            return 'Televisi√≥n'
        elif re.search(r'redes sociales|digital|web|internet|p√°gina|email', description):
            return 'Medio Digital/Web'
        elif re.search(r'dise√±o|edici√≥n|impresi√≥n', description):
            return 'Dise√±o/Impresi√≥n'
        else:
            return 'Otros'

    df['Categoria'] = df['Descripci√≥n'].apply(categorize_description)
    return df

# --- CostosAvisosApp functionality (adapted for Streamlit) ---
def costos_avisos_page(df_processed):
    st.markdown("## An√°lisis de Costos y Avisos")

    if df_processed.empty:
        st.warning("No hay datos cargados para mostrar el an√°lisis de costos y avisos.")
        return

    st.markdown("### Total de Costos por A√±o")
    costo_por_a√±o = df_processed.groupby('A√±o')['Costo Total'].sum().reset_index()
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.barplot(x='A√±o', y='Costo Total', data=costo_por_a√±o, palette='viridis', ax=ax)
    ax.set_title('Costo Total de Avisos por A√±o')
    ax.set_xlabel('A√±o')
    ax.set_ylabel('Costo Total')
    ax.ticklabel_format(style='plain', axis='y') # Remove scientific notation
    st.pyplot(fig)
    st.dataframe(costo_por_a√±o)

    st.markdown("### Distribuci√≥n de Costos por Categor√≠a")
    costo_por_categoria = df_processed.groupby('Categoria')['Costo Total'].sum().sort_values(ascending=False).reset_index()
    fig, ax = plt.subplots(figsize=(12, 7))
    sns.barplot(x='Costo Total', y='Categoria', data=costo_por_categoria, palette='magma', ax=ax)
    ax.set_title('Costo Total por Categor√≠a de Aviso')
    ax.set_xlabel('Costo Total')
    ax.set_ylabel('Categor√≠a')
    ax.ticklabel_format(style='plain', axis='x') # Remove scientific notation
    st.pyplot(fig)
    st.dataframe(costo_por_categoria)

    st.markdown("### Top 10 Avisos m√°s Costosos")
    top_10_avisos = df_processed.nlargest(10, 'Costo Total')[['Descripci√≥n', 'Costo Total', 'Fecha de Registro']].reset_index(drop=True)
    st.dataframe(top_10_avisos)

    st.markdown("### Costos Mensuales")
    df_processed['Mes-A√±o'] = df_processed['Fecha de Registro'].dt.to_period('M')
    costo_mensual = df_processed.groupby('Mes-A√±o')['Costo Total'].sum().sort_index().reset_index()
    costo_mensual['Mes-A√±o'] = costo_mensual['Mes-A√±o'].astype(str) # Convert Period to string for plotting
    fig, ax = plt.subplots(figsize=(15, 7))
    sns.lineplot(x='Mes-A√±o', y='Costo Total', data=costo_mensual, marker='o', ax=ax)
    ax.set_title('Tendencia de Costos Mensuales')
    ax.set_xlabel('Mes-A√±o')
    ax.set_ylabel('Costo Total')
    ax.ticklabel_format(style='plain', axis='y')
    plt.xticks(rotation=45)
    st.pyplot(fig)
    st.dataframe(costo_mensual)

    st.markdown("### Resumen de Avisos por Categor√≠a y A√±o")
    pivot_table = pd.pivot_table(df_processed, values='Costo Total', index='Categoria', columns='A√±o', aggfunc='sum', fill_value=0)
    st.dataframe(pivot_table)

    st.markdown("### Costo Promedio por Aviso")
    df_processed['Costo por Aviso'] = df_processed['Costo Total'] / df_processed['Cantidad']
    promedio_costo_aviso = df_processed['Costo por Aviso'].mean()
    st.write(f"El costo promedio por aviso es: ${promedio_costo_aviso:,.2f}")

# --- EvaluacionApp functionality (adapted for Streamlit) ---
def evaluacion_page(df_processed):
    st.markdown("## Evaluaci√≥n de Avisos")

    if df_processed.empty:
        st.warning("No hay datos cargados para la evaluaci√≥n.")
        return

    st.markdown("### Conteo de Avisos por A√±o")
    avisos_por_a√±o = df_processed['A√±o'].value_counts().sort_index().reset_index()
    avisos_por_a√±o.columns = ['A√±o', 'N√∫mero de Avisos']
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.barplot(x='A√±o', y='N√∫mero de Avisos', data=avisos_por_a√±o, palette='pastel', ax=ax)
    ax.set_title('N√∫mero de Avisos por A√±o')
    ax.set_xlabel('A√±o')
    ax.set_ylabel('N√∫mero de Avisos')
    st.pyplot(fig)
    st.dataframe(avisos_por_a√±o)

    st.markdown("### Conteo de Avisos por Categor√≠a")
    avisos_por_categoria = df_processed['Categoria'].value_counts().reset_index()
    avisos_por_categoria.columns = ['Categoria', 'N√∫mero de Avisos']
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.barplot(x='N√∫mero de Avisos', y='Categoria', data=avisos_por_categoria, palette='coolwarm', ax=ax)
    ax.set_title('N√∫mero de Avisos por Categor√≠a')
    ax.set_xlabel('N√∫mero de Avisos')
    ax.set_ylabel('Categor√≠a')
    st.pyplot(fig)
    st.dataframe(avisos_por_categoria)

    st.markdown("### Distribuci√≥n de Avisos por D√≠a de la Semana")
    df_processed['Dia_Semana'] = df_processed['Fecha de Registro'].dt.day_name(locale='es_ES') # Use Spanish locale
    dias_orden = ['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado', 'Domingo']
    df_processed['Dia_Semana'] = pd.Categorical(df_processed['Dia_Semana'], categories=dias_orden, ordered=True)
    avisos_por_dia = df_processed['Dia_Semana'].value_counts().sort_index().reset_index()
    avisos_por_dia.columns = ['D√≠a de la Semana', 'N√∫mero de Avisos']
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.barplot(x='D√≠a de la Semana', y='N√∫mero de Avisos', data=avisos_por_dia, palette='cubehelix', ax=ax)
    ax.set_title('N√∫mero de Avisos por D√≠a de la Semana')
    ax.set_xlabel('D√≠a de la Semana')
    ax.set_ylabel('N√∫mero de Avisos')
    st.pyplot(fig)
    st.dataframe(avisos_por_dia)

    st.markdown("### Conteo de Avisos por Mes")
    df_processed['Mes'] = df_processed['Fecha de Registro'].dt.month_name(locale='es_ES')
    meses_orden = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
    df_processed['Mes'] = pd.Categorical(df_processed['Mes'], categories=meses_orden, ordered=True)
    avisos_por_mes = df_processed['Mes'].value_counts().sort_index().reset_index()
    avisos_por_mes.columns = ['Mes', 'N√∫mero de Avisos']
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.barplot(x='Mes', y='N√∫mero de Avisos', data=avisos_por_mes, palette='plasma', ax=ax)
    ax.set_title('N√∫mero de Avisos por Mes')
    ax.set_xlabel('Mes')
    ax.set_ylabel('N√∫mero de Avisos')
    plt.xticks(rotation=45)
    st.pyplot(fig)
    st.dataframe(avisos_por_mes)


# --- Main Streamlit App ---
def main():
    st.set_page_config(
        page_title="An√°lisis de Avisos y Costos",
        page_icon=":bar_chart:",
        layout="wide"
    )

    st.sidebar.title("Navegaci√≥n")
    menu_options = {
        "Inicio": "home",
        "Costos y Avisos": "costos_avisos",
        "Evaluaci√≥n de Avisos": "evaluacion",
        "Descargar Datos Procesados": "download"
    }
    choice = st.sidebar.radio("Selecciona una opci√≥n", list(menu_options.keys()))

    st.title("Sistema de An√°lisis de Avisos Publicitarios")

    # File uploader always visible
    uploaded_file = st.sidebar.file_uploader("Sube tu archivo Excel (avisos_filtrados.xlsx)", type=["xlsx"])
    
    # Load and preprocess data only once
    df = load_data(uploaded_file)
    df_processed = preprocess_data(df.copy()) # Pass a copy to avoid modifying original cached df

    if menu_options[choice] == "home":
        st.markdown("""
        Bienvenido al sistema de an√°lisis de avisos publicitarios.
        
        Sube tu archivo `avisos_filtrados.xlsx` usando el cargador de archivos en la barra lateral para comenzar.
        
        Una vez cargados los datos, podr√°s navegar a trav√©s de las diferentes secciones para explorar:
        - **Costos y Avisos**: An√°lisis detallado de los costos asociados a los avisos, tendencias anuales, por categor√≠a, y top avisos.
        - **Evaluaci√≥n de Avisos**: Conteo y distribuci√≥n de avisos por a√±o, categor√≠a, d√≠a de la semana y mes.
        """)
        if not df_processed.empty:
            st.markdown("### Vista Previa de los Datos Cargados y Procesados")
            st.dataframe(df_processed.head())

    elif menu_options[choice] == "costos_avisos":
        costos_avisos_page(df_processed)

    elif menu_options[choice] == "evaluacion":
        evaluacion_page(df_processed)

    elif menu_options[choice] == "download":
        st.markdown("## Descargar Datos Procesados")
        if not df_processed.empty:
            st.write("Haz clic en el bot√≥n de abajo para descargar los datos procesados en formato Excel.")
            
            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                df_processed.to_excel(writer, index=False, sheet_name='Datos_Procesados')
            output.seek(0)
            
            st.download_button(
                label="Descargar Datos Procesados (Excel)",
                data=output.getvalue(),
                file_name="avisos_procesados.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
        else:
            st.warning("No hay datos procesados para descargar. Por favor, carga un archivo primero.")

if __name__ == "__main__":
    main()
